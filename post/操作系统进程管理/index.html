<!DOCTYPE html>
<html
  dir="ltr"
  lang="en"
  data-theme=""
  class="html"
><head>
  <title>
    
      CJC
        |
        操作系统进程管理


      


    
  </title>

  
  <meta charset="utf-8" /><meta name="generator" content="Hugo 0.97.3" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="author" content="CJC" />
  <meta
    name="description"
    content="
      Integrity
Goodness
Passion
H O P E



    "
  />
  
  
    
    
    <link
      rel="stylesheet"
      href="/scss/main.min.5551757e3608c8c17519a404d0c78646f8b4ce68b04e5acc290a21597ce09467.css"
      integrity="sha256-VVF1fjYIyMF1GaQE0MeGRvi0zmiwTlrMKQohWXzglGc="
      crossorigin="anonymous"
      type="text/css"
    />

  

  
  <link
    rel="stylesheet"
    href="/css/markupHighlight.min.31b0a1f317f55c529a460897848c97436bb138b19c399b37de70d463a8bf6ed5.css"
    integrity="sha256-MbCh8xf1XFKaRgiXhIyXQ2uxOLGcOZs33nDUY6i/btU="
    crossorigin="anonymous"
    type="text/css"
  />
  
  
  <link
    rel="stylesheet"
    href="/fontawesome/css/fontawesome.min.69685904d5c2a0c6258d03c207b778c10466edf6cea928cc0164c376b0ad0930.css"
    integrity="sha256-aWhZBNXCoMYljQPCB7d4wQRm7fbOqSjMAWTDdrCtCTA="
    crossorigin="anonymous"
    type="text/css"
  />
  
  <link
    rel="stylesheet"
    href="/fontawesome/css/solid.min.6d585e78d28cce1200d39fb133c92ed83df01738da721d0f48fb6eac62d24e04.css"
    integrity="sha256-bVheeNKMzhIA05&#43;xM8ku2D3wFzjach0PSPturGLSTgQ="
    crossorigin="anonymous"
    type="text/css"
  />
  
  <link
    rel="stylesheet"
    href="/fontawesome/css/brands.min.6b00d96498d59caa0dbcf9b49d30d821915291f2ceb0e19248523c8607ff43fa.css"
    integrity="sha256-awDZZJjVnKoNvPm0nTDYIZFSkfLOsOGSSFI8hgf/Q/o="
    crossorigin="anonymous"
    type="text/css"
  />
  
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />

  <link rel="canonical" href="https://example.com/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" />

  
  
  
  
  <script
    type="text/javascript"
    src="/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js"
    integrity="sha256-&#43;RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI="
    crossorigin="anonymous"
  ></script>

  
    
    
    <script
      type="text/javascript"
      src="/js/anatole-theme-switcher.min.560a26330d27ff44a44e83b53cd07a95d4230a65930d31c5c76a8d481e5b35bf.js"
      integrity="sha256-VgomMw0n/0SkToO1PNB6ldQjCmWTDTHFx2qNSB5bNb8="
      crossorigin="anonymous"
    ></script>

  

  


  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="操作系统进程管理"/>
<meta name="twitter:description" content="进程管理 进程，线程，协程分别是什么？区别是什么？ 进程：首先进程其实是运行起来的程序，是资源(包括内存、打开的文件等)分配的单位，每个进程都有自己的独立虚拟地址空间，拥有自己独立的堆和栈，上下文切换开销比较大。
线程：线程是 CPU 调度的单位，线程只会有运行时需要的必不可少的资源（程序计数器，寄存器，栈），它的栈是独立的，但是堆是共享的，线程可以享有这个进程内所有的共享资源。上下文切换开销比进程小。线程的作用：线程能减少并发执行的时间和空间开销。（注意：当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃。这里是针对 C/C&#43;&#43; 语言，Java语言中的线程奔溃不会造成进程崩溃）。
协程：一种用户态的轻量级线程，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的。协程和线程一样共享堆，不共享栈，发生上下文切换的时候，因为是用户态的，所以没有内核切换的开销，上下文切换的会比较快。
区别："/>



  
  <meta property="og:title" content="操作系统进程管理" />
<meta property="og:description" content="进程管理 进程，线程，协程分别是什么？区别是什么？ 进程：首先进程其实是运行起来的程序，是资源(包括内存、打开的文件等)分配的单位，每个进程都有自己的独立虚拟地址空间，拥有自己独立的堆和栈，上下文切换开销比较大。
线程：线程是 CPU 调度的单位，线程只会有运行时需要的必不可少的资源（程序计数器，寄存器，栈），它的栈是独立的，但是堆是共享的，线程可以享有这个进程内所有的共享资源。上下文切换开销比进程小。线程的作用：线程能减少并发执行的时间和空间开销。（注意：当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃。这里是针对 C/C&#43;&#43; 语言，Java语言中的线程奔溃不会造成进程崩溃）。
协程：一种用户态的轻量级线程，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的。协程和线程一样共享堆，不共享栈，发生上下文切换的时候，因为是用户态的，所以没有内核切换的开销，上下文切换的会比较快。
区别：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://example.com/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-05-07T19:08:46+08:00" />
<meta property="article:modified_time" content="2022-05-07T19:08:46+08:00" /><meta property="og:site_name" content="CJC&#39;s time&amp;space" />




  
  
  
  
  <script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "articleSection": "post",
        "name": "操作系统进程管理",
        "headline": "操作系统进程管理",
        "alternativeHeadline": "",
        "description": "
      
        进程管理 进程，线程，协程分别是什么？区别是什么？ 进程：首先进程其实是运行起来的程序，是资源(包括内存、打开的文件等)分配的单位，每个进程都有自己的独立虚拟地址空间，拥有自己独立的堆和栈，上下文切换开销比较大。\n线程：线程是 CPU 调度的单位，线程只会有运行时需要的必不可少的资源（程序计数器，寄存器，栈），它的栈是独立的，但是堆是共享的，线程可以享有这个进程内所有的共享资源。上下文切换开销比进程小。线程的作用：线程能减少并发执行的时间和空间开销。（注意：当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃。这里是针对 C\/C\u002b\u002b 语言，Java语言中的线程奔溃不会造成进程崩溃）。\n协程：一种用户态的轻量级线程，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的。协程和线程一样共享堆，不共享栈，发生上下文切换的时候，因为是用户态的，所以没有内核切换的开销，上下文切换的会比较快。\n区别：


      


    ",
        "inLanguage": "en",
        "isFamilyFriendly": "true",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/example.com\/post\/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86\/"
        },
        "author" : {
            "@type": "Person",
            "name": "CJC"
        },
        "creator" : {
            "@type": "Person",
            "name": "CJC"
        },
        "accountablePerson" : {
            "@type": "Person",
            "name": "CJC"
        },
        "copyrightHolder" : {
            "@type": "Person",
            "name": "CJC"
        },
        "copyrightYear" : "2022",
        "dateCreated": "2022-05-07T19:08:46.00Z",
        "datePublished": "2022-05-07T19:08:46.00Z",
        "dateModified": "2022-05-07T19:08:46.00Z",
        "publisher":{
            "@type":"Organization",
            "name": "CJC",
            "url": "https://example.com",
            "logo": {
                "@type": "ImageObject",
                "url": "https:\/\/example.comfavicon-32x32.png",
                "width":"32",
                "height":"32"
            }
        },
        "image": 
      [
      ]

    ,
        "url" : "https:\/\/example.com\/post\/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86\/",
        "wordCount" : "431",
        "genre" : [ 
      
      "操作系统"

    ],
        "keywords" : [ 
      
      "操作系统进程管理"

    ]
    }
  </script>



</head>
<body
    
      class="body theme--light"

    
  >
    <div class="wrapper">
      <aside
        
          class="wrapper__sidebar"

        
      ><div
  class="sidebar
    animated fadeInDown

  "
>
  <div class="sidebar__content">
    <div class="sidebar__introduction">
      <img
        class="sidebar__introduction-profileimage"
        src="/images/cat.jpeg"
        alt="profile picture"
      />
      
        <div class="sidebar__introduction-title">
          <a href="/">CJC&#39;s time&amp;space</a>
        </div>

      
      <div class="sidebar__introduction-description">
        <p>Integrity<br />Goodness<br />Passion<br />H O P E<br /></p>
      </div>
    </div>
    <ul class="sidebar__list">
      
        <li class="sidebar__list-item">
          <a href="https://github.com/CJC-2468" rel="me" aria-label="GitHub" title="GitHub">
            <i class="fab fa-github fa-2x" aria-hidden="true"></i>
          </a>
        </li>

      
        <li class="sidebar__list-item">
          <a href="mailto:jccheng2022@gmail.com" rel="me" aria-label="e-mail" title="e-mail">
            <i class="fas fa-envelope fa-2x" aria-hidden="true"></i>
          </a>
        </li>

      
        <li class="sidebar__list-item">
          <a href="#" rel="me" aria-label="instagram" title="instagram">
            <i class="fab fa-instagram fa-2x" aria-hidden="true"></i>
          </a>
        </li>

      
        <li class="sidebar__list-item">
          <a href="#" rel="me" aria-label="Linkedin" title="Linkedin">
            <i class="fab fa-linkedin fa-2x" aria-hidden="true"></i>
          </a>
        </li>

      
    </ul>
  </div><footer class="footer footer__sidebar">
  <ul class="footer__list">
    <li class="footer__item">
      &copy;
      
        CJC
        2022


      
    </li>
    
  </ul>
</footer>
  
  <script
    type="text/javascript"
    src="/js/medium-zoom.min.9c062c557275acbaba71f0c7cd4024da3e3cc825d248bc4b2130811b0965330b.js"
    integrity="sha256-nAYsVXJ1rLq6cfDHzUAk2j48yCXSSLxLITCBGwllMws="
    crossorigin="anonymous"
  ></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-5HQND29S4G"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag('js', new Date());
  gtag('config', 'G-5HQND29S4G');
</script>
</div>
</aside>
      <main
        
          class="wrapper__main"

        
      >
        <header class="header"><div
  class="
    animated fadeInDown

  "
>
  <a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false">
    <span aria-hidden="true" class="navbar-burger__line"></span>
    <span aria-hidden="true" class="navbar-burger__line"></span>
    <span aria-hidden="true" class="navbar-burger__line"></span>
  </a>
  <nav class="nav">
    <ul class="nav__list" id="navMenu">
      
      
        
        <li class="nav__list-item">
          <a
            
            href="/"
            
            title=""
            >Home</a
          >
        </li>

      
        
        <li class="nav__list-item">
          <a
            
            href="/post/"
            
            title=""
            >目录</a
          >
        </li>

      
        
        <li class="nav__list-item">
          <a
            
            href="/categories/"
            
            title=""
            >分类</a
          >
        </li>

      
        
        <li class="nav__list-item">
          <a
            
            href="/tags/"
            
            title=""
            >标签</a
          >
        </li>

      
        
        <li class="nav__list-item">
          <a
            
            href="/wikif"
            
            title=""
            >个人探索</a
          >
        </li>

      
    </ul>
    <ul class="nav__list nav__list--end">
      
      
        <li class="nav__list-item">
          <div class="themeswitch">
            <a title="Switch Theme">
              <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a>
          </div>
        </li>

      
    </ul>
  </nav>
</div>
</header>
  <div
    class="post 
      animated fadeInDown

    "
  >
    
    <div class="post__content">
      <h1>操作系统进程管理</h1>
      
        <ul class="post__meta">
          <li class="post__meta-item">
            <em class="fas fa-calendar-day post__meta-icon"></em>
            <span class="post__meta-text"
              >
                Sat, May 7, 2022


              
            </span>
          </li>
          <li class="post__meta-item">
            <em class="fas fa-stopwatch post__meta-icon"></em>
            <span class="post__meta-text">3-minute read</span>
          </li>
        </ul>

      <h2 id="进程管理">进程管理</h2>
<h3 id="进程线程协程分别是什么区别是什么">进程，线程，协程分别是什么？区别是什么？</h3>
<p>进程：首先进程其实是运行起来的程序，是资源(包括内存、打开的文件等)分配的单位，每个进程都有自己的独立虚拟地址空间，拥有自己独立的堆和栈，上下文切换开销比较大。</p>
<p>线程：线程是 CPU 调度的单位，线程只会有运行时需要的必不可少的资源（程序计数器，寄存器，栈），它的栈是独立的，但是堆是共享的，线程可以享有这个进程内所有的共享资源。上下文切换开销比进程小。线程的作用：线程能减少并发执行的时间和空间开销。（注意：当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃。这里是针对 C/C++ 语言，Java语言中的线程奔溃不会造成进程崩溃）。</p>
<p>协程：一种用户态的轻量级线程，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的。协程和线程一样共享堆，不共享栈，发生上下文切换的时候，因为是用户态的，所以没有内核切换的开销，上下文切换的会比较快。</p>
<p><strong>区别：</strong></p>
<p>分配单位区别：进程是资源(包括内存、打开的文件等)分配的单位，线程是 CPU 调度的单位</p>
<p>大小区别：进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；进程初始就是MB级别的，goroutine初始只有2KB。线程linux默认是1MB，但是这个是虚拟内存大小，实际上是200K。</p>
<p>调度区别：</p>
<p>对于 进程**、**线程（内核级），都是由内核进行调度，有 CPU 时间片的概念，发生抢占式调度（有多种调度算法）。</p>
<p>对于 协程(用户级线程)，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的，因为是由用户程序自己控制，那么就很难像抢占式调度那样做到强制的 CPU 控制权切换到其他进程/线程，通常只能进行 协作式调度，需要协程自己主动把控制权转让出去之后，其他协程才能被执行到。 但是goroutine在协程基础上做了封装，很好的解决了这个问题。</p>
<h3 id="什么是进程控制块">什么是进程控制块？</h3>
<p>PCB 是进程存在的唯一标识。包含以下信息：</p>
<p>进程描述信息：</p>
<ul>
<li>进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；</li>
<li>用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；</li>
</ul>
<p>进程控制和管理信息：</p>
<ul>
<li>进程当前状态，如 new、ready、running、waiting 或 blocked 等；</li>
<li>进程优先级：进程抢占 CPU 时的优先级；</li>
</ul>
<p>资源分配清单：有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。</p>
<p>CPU 相关信息：CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。</p>
<p>PCB的组织方式？</p>
<p>通常是通过链表的方式进行组织，把具有相同状态的进程链在一起，比如阻塞队列，就绪队列。</p>
<h3 id="进程有几种基本状态">进程有几种基本状态？</h3>
<p><strong>创建状态(new)</strong> ：进程正在被创建，尚未到就绪状态。</p>
<p><strong>就绪状态(ready)</strong> ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。</p>
<p><strong>运行状态(running)</strong> ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。</p>
<p><strong>阻塞状态(waiting)</strong> ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。</p>
<p><strong>结束状态(terminated)</strong> ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。</p>
<img src="https://cjcpicgoimg.oss-cn-beijing.aliyuncs.com/img/20220506092654.png" style="zoom:50%;" />
<p>挂起状态：内存空间有限，阻塞或者就绪的进程被换到硬盘上的时候，就没有占用实际的物理内存空间，这种就叫挂起。</p>
<h3 id="进程之间通信方式">进程之间通信方式？</h3>
<p>共6种方式：</p>
<p><strong>管道</strong>：有两种。</p>
<p>匿名管道：比如linux命令行的竖线，平时ps aus后面会加竖线再grep一下我们需要的信息，所以管道传输数据其实是一种单向的。在 shell 里面执行 <code>A | B</code>命令的时候，A 进程和 B 进程都是 shell 创建出来的子进程，A 和 B 之间不存在父子关系，它俩的父进程都是 shell，共用父进程的文件描述符。<strong>对于匿名管道，它的通信范围是存在父子关系的进程</strong>。</p>
<img src="https://cjcpicgoimg.oss-cn-beijing.aliyuncs.com/img/20220506182305.png" style="zoom:33%;" />
<p>命名管道：mkfifo命令创建一个有名管道，也被叫做 <code>FIFO</code>，因为数据是先进先出的传输方式。<strong>对于命名管道，它可以在不相关的进程间也能相互通信</strong>。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。</p>
<p>不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中。</p>
<p>优点是简单，缺点管道这种通信方式效率低，不适合进程间频繁地交换数据。</p>
<p><strong>消息队列</strong>：保存在内核中的<strong>消息链表</strong>，在发送数据时，会分成一个一个独立的数据单元，也就是消息体(数据块)，消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</p>
<p>优点是不同进程之间通信方便，缺点是消息队列不适合比较大数据的传输，因为在内核中每个消息体都有一个最大⻓度的限制，消息队列通信过程中，存在用户态与内核态之间的数据拷⻉开销。因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。</p>
<p><strong>共享内存</strong>：共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中。使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。</p>
<img src="https://cjcpicgoimg.oss-cn-beijing.aliyuncs.com/img/20220506183415.png" style="zoom: 25%;" />
<p><strong>信号量</strong>：信号量主要依赖于一个计数器，用于避免多进程访问共享资源时造成的数据混乱，目的在于进程间同步，而不是强调通信的数据。有两种原子操作：P，V。信号初始化为 <code>1</code>，就代表着是<strong>互斥信号量</strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。信号初始化为 <code>0</code>，就代表着是<strong>同步信号量</strong>，它可以保证进程 A 应在进程 B 之前执行。</p>
<p><strong>信号</strong>：上面说的进程间通信，都是常规状态下的工作模式。对于异常情况下的工作模式，就需要用 「信号」的方式来通知进程。例如control+c会给进程发信号表示终止该进程，control+z会挂起某个进程。信号事件的来源主要有硬件来源(如键盘 Cltr+C )和软件来源(如 kill 命令)。 **信号是进程间通信机制中唯一的异步通信机制，因为可以在任何时候发送信号给某一进程。**有些信号能自定义，有些不能（比如kill），可以自己写一些信号处理函数捕捉信号。常见sigkill，sigterm信号。</p>
<p><strong>socket</strong>：跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。本地也可以用。</p>
<p>根据创建 socket 类型的不同，通信的方式也就不同：</p>
<ul>
<li>实现 TCP 字节流通信： socket 类型是 AF_INET 和 SOCK_STREAM；</li>
<li>实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM；</li>
<li>实现本地进程间通信： 「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket；</li>
</ul>
<p>远程TCP：这里需要注意的是，服务端调用 <code>accept</code> 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。所以，监听的 socket 和真正用来传送数据的 socket，是「<strong>两个</strong>」 socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong>。</p>
<img src="https://cjcpicgoimg.oss-cn-beijing.aliyuncs.com/img/20220506185317.png" style="zoom:33%;" />
<p>远程UDP ：没有连接的，所以不需要三次握手，也就不需要像 TCP 调用 listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端口号，因此也需要 bind。</p>
<p>对于 UDP 来说，不需要要维护连接，那么也就没有所谓的发送方和接收方，甚至都不存在客户端和服务端的概念，只要有一个 socket 多台机器就可以任意通信，因此每一个 UDP 的 socket 都需要 bind。</p>
<p>本地通信：本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是<strong>绑定一个本地文件</strong>，这也就是它们之间的最大区别。</p>
<h3 id="线程之间通信方式">线程之间通信方式？</h3>
<p>同一进程的线程共享地址空间,没有通信的必要，但要做好同步/互斥,保护共享的全局变量。</p>
<p>所以一般都是讲不同的线程之间通信方式：</p>
<ul>
<li>
<p>锁机制：互斥锁，读写锁</p>
</li>
<li>
<p>信号量机制(Semaphore)</p>
</li>
<li>
<p>wait/notify 等待: 调用wait方法会使该线程进入等待状态，并且会释放被同步对象的锁,notify操作可以唤醒一个因执行wait而处于阻塞状态的线程，使其进入就绪状态，被唤醒的线程会去尝试着获取对象锁，然后执行wait之后的代码.</p>
</li>
<li>
<p>Volatile 内存共享：利用volatile可见性特点来实现线程通信，volatile语义有两个原则.1.所有volatile修饰的变量一旦被某个线程更改，必须立即刷新到主内存 2.所有volatile修饰的变量在使用之前必须重新读取主内存的值</p>
<p>原理：工作内存2能够感知到工作内存1更新a值是靠的总线，工作内存1在将值刷新的主内存时必须经过总线，总线就能告知其他线程有值被改变，那么其他线程就会主动读取主内存的值来更新。基于总线嗅探机制的 MESI 协议来实现多处理器下的缓存一致性。<strong>每个处理器通过嗅探在总线上传播的数据来检查自己的缓存值是不是过期了，如果处理器发现自己缓存被修改，就会将当前处理器的缓存设置无效状态</strong>，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据库读到处理器缓存中。</p>
<img src="https://cjcpicgoimg.oss-cn-beijing.aliyuncs.com/img/20220330140853.png" style="zoom:33%;" />
</li>
</ul>
<h3 id="进程切换和线程切换为什么线程切换消耗更小">进程切换和线程切换，为什么线程切换消耗更小？</h3>
<p>进程切换实际上就是<strong>CPU上下文切换</strong>，进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。CPU的寄存器的值和程序计数器的值会保存到PCB里面。</p>
<p>当要运行另外一个进程的时候，我们需要从这个进程的 PCB 取出上下文，然后恢复到 CPU 中，这使得这个进程可以继续执行，如下图所示：</p>
<img src="https://cjcpicgoimg.oss-cn-beijing.aliyuncs.com/img/20220506094230.png" style="zoom:50%;" />
<p>最主要的一个区别在于进程切换涉及虚拟地址空间的切换而线程不会。因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及<strong>虚拟地址空间</strong>的转换。</p>
<p><strong>为什么虚拟地址空间切换会比较耗时呢？<strong>把虚拟地址转换为物理地址需要查找</strong>页表</strong>，页表查找是一个很慢的过程，因此通常使用Cache来缓存常用的地址映射，这样可以加速页表查找，这个cache就是<strong>TLB</strong>。由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么当进程切换后页表也要进行切换，页表切换后TLB就失效了，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程无需切换地址空间，因此我们通常说线程切换要比较进程切换块，原因就在这里。</p>
<p>什么时候会发生上下文切换？</p>
<p>时间片用完，等待io资源，有更高优先级的进程来。</p>
<h3 id="什么是临界区什么是互斥和同步">什么是临界区？什么是互斥和同步？</h3>
<p>访问临界资源/共享资源的代码片段叫临界区，一次只能一个进程访问的资源叫做临界资源。互斥：对于临界资源的访问，多个进程中一次只能有一个进程访问，这种情形就是互斥。同步：多个进程之间相互协作去完成某项任务，他们之间可能存在一种先后顺序，这就叫做进程同步。</p>
<h3 id="怎么实现互斥和同步">怎么实现互斥和同步？</h3>
<ul>
<li><em>锁</em>：加锁、解锁操作；</li>
<li><em>信号量</em>：P、V 操作；</li>
</ul>
<p>这两个都可以方便地实现进程/线程互斥，而信号量比锁的功能更强一些，它还可以方便地实现进程/线程同步。</p>
<p>信号量是操作系统提供的一种协调共享资源访问的方法。通常<strong>信号量表示资源的数量</strong>，对应的变量是一个整型（<code>sem</code>）变量。另外，还有<strong>两个原子操作的系统调用函数来控制信号量的</strong>，分别是：</p>
<ul>
<li><em>P 操作</em>：将 <code>sem</code> 减 <code>1</code>，相减后，如果 <code>sem &lt; 0</code>，则进程/线程进入阻塞等待，否则继续，表明 P 操作可能会阻塞；</li>
<li><em>V 操作</em>：将 <code>sem</code> 加 <code>1</code>，相加后，如果 <code>sem &lt;= 0</code>，唤醒一个等待中的进程/线程，表明 V 操作不会阻塞；</li>
</ul>
<p>PV 操作的函数是由操作系统管理和实现的，所以操作系统已经使得执行 PV 函数时是具有原子性的。成对出现。</p>
<h3 id="生产者消费者问题">生产者消费者问题</h3>
<p>生产者-消费者问题描述：生产者在生成数据后，放在一个缓冲区中；消费者从缓冲区取出数据处理；任何时刻，只能有一个生产者或消费者可以访问缓冲区；</p>
<p>我们对问题分析可以得出：</p>
<ul>
<li>任何时刻只能有一个线程操作缓冲区，说明操作缓冲区是临界代码，<strong>需要互斥</strong>；</li>
<li>缓冲区空时，消费者必须等待生产者生成数据；缓冲区满时，生产者必须等待消费者取出数据。说明生产者和消费者<strong>需要同步</strong>。</li>
</ul>
<p>那么我们需要三个信号量，分别是：</p>
<ul>
<li>互斥信号量 <code>mutex</code>：用于互斥访问缓冲区，初始化值为 1；</li>
<li>资源信号量 <code>fullBuffers</code>：用于消费者询问缓冲区是否有数据，有数据则读取数据，初始化值为 0（表明缓冲区一开始为空）；</li>
<li>资源信号量 <code>emptyBuffers</code>：用于生产者询问缓冲区是否有空位，有空位则生成数据，初始化值为 n （缓冲区大小）；</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mutex</span>       <span class="p">=</span> <span class="mi">1</span>  <span class="c1">//互斥信号量，用于缓冲区的互斥访问
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fullBuffer</span>  <span class="p">=</span> <span class="mi">10</span> <span class="c1">//表示缓冲区满槽个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">emptyBuffer</span> <span class="p">=</span> <span class="mi">0</span>  <span class="c1">//表示缓冲区空槽个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">producer</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">P</span><span class="p">(</span><span class="nx">emptyBuffer</span><span class="p">)</span> <span class="c1">//将空槽个数-1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">P</span><span class="p">(</span><span class="nx">mutex</span><span class="p">)</span>       <span class="c1">//进入临界区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">//放数据进去
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">V</span><span class="p">(</span><span class="nx">mutex</span><span class="p">)</span>      <span class="c1">//离开临界区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">V</span><span class="p">(</span><span class="nx">fullBuffer</span><span class="p">)</span> <span class="c1">//将满槽个数+1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">consumer</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">P</span><span class="p">(</span><span class="nx">fullBuffer</span><span class="p">)</span> <span class="c1">//将满槽个数-1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">P</span><span class="p">(</span><span class="nx">mutex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//放数据进去
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">V</span><span class="p">(</span><span class="nx">mutex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nf">V</span><span class="p">(</span><span class="nx">emptyBuffer</span><span class="p">)</span> <span class="c1">//将空槽个数+1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="什么是死锁死锁要满足的条件是什么怎么检测怎么避免">什么是死锁？死锁要满足的条件是什么？怎么检测？怎么避免？</h3>
<p>多个进程争抢临界资源时，由于资源上竞争问题，造成所有进程都阻塞了，在没有外力作用的情况下，所有进程都无法继续推进，这种情况就是系统发生了死锁。</p>
<p>死锁的四个条件是：互斥，持有并请求，不可剥夺，环路等待。</p>
<p>检测：golang里可以用pprof，或者自己写单元测试打印log，当然也有一些开源项目也可以。</p>
<p>避免：破坏死锁的四个条件。例如，最常用的方法就是使用资源有序分配法，来破环环路等待条件。</p>
<h3 id="什么是互斥锁自旋锁读写锁乐观锁和悲观锁">什么是互斥锁，自旋锁，读写锁，乐观锁和悲观锁？</h3>
<p>有很多高级的锁都是基于互斥锁和自旋锁（忙等锁）实现的。加锁的目的就是保证共享资源在任意时间里，只有一个线程访问，这样就可以避免多线程导致共享数据错乱。</p>
<p>区别：当已经有一个线程加锁后，其他线程加锁则就会失败，互斥锁和自旋锁对于加锁失败后的处理方式是不一样的：</p>
<ul>
<li>互斥锁加锁失败后，线程会<strong>释放 CPU</strong> ，给其他线程；对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的，会发生两次线程上下文切换，开销大。</li>
<li>自旋锁加锁失败后，线程会<strong>忙等待</strong>，直到它拿到锁；不会发生上下文切换，开销小。自旋锁在单cpu的情况下需要抢占式调度，不然它永远不会放弃cpu。</li>
</ul>
<p>使用场景：如果你能确定被锁住的代码执行时间很短就用自旋锁，否则使用互斥锁。因为涉及上下文切换的时间可能比临界区代码执行时间还长，不划算。</p>
<p>自旋锁的底层是用CAS实现的。</p>
<p>一般加锁的过程，包含两个步骤：</p>
<ul>
<li>第一步，查看锁的状态，如果锁是空闲的，则执行第二步；</li>
<li>第二步，将锁设置为当前线程持有；</li>
</ul>
<p>CAS 会把这两个步骤合并成一条硬件级指令，形成<strong>原子指令</strong>，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行。</p>
<p>使用自旋锁的时候，当发生多线程竞争锁的情况，加锁失败的线程会「忙等待」，直到它拿到锁。这里的「忙等待」可以用 <code>while</code> 循环等待实现，不过最好是使用 CPU 提供的 <code>PAUSE</code> 指令来实现「忙等待」，因为可以减少循环等待时的耗电量。</p>
<p>读写锁：由「读锁」和「写锁」两部分构成，如果只读取共享资源用「读锁」加锁，如果要修改共享资源则用「写锁」加锁。又分为读优先，写优先，公平读写锁（用队列实现）。</p>
<p>乐观锁：它假定冲突的概率很低，它的工作方式是：先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。乐观锁全程并没有加锁，所以它也叫无锁编程。</p>
<p>悲观锁：互斥锁、自旋锁、读写锁，都是属于悲观锁。这种认为多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁。</p>
<p>场景：只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。</p>
<p>CAS 不是乐观锁吗，为什么基于 CAS 实现的自旋锁是悲观锁？乐观锁是先修改同步资源，再验证有没有发生冲突。悲观锁是修改共享数据前，都要先加锁，防止竞争。CAS 是乐观锁没错，但是 CAS 和自旋锁不同之处，自旋锁基于 CAS 加了while 产生自旋的效果，加锁失败会忙等待直到拿到锁，自旋锁是要需要事先拿到锁才能修改数据的，所以算悲观锁。</p>
<h3 id="讲讲cas">讲讲CAS？</h3>
<p>背景：</p>
<p>CAS（Compare-and-Swap），即比较并替换，是一种实现并发时常用到的思想。</p>
<p>当多个线程同时使用 CAS 更新同一个变量时，只有其中一个线程能够操作成功，而其他线程都会更新失败。不过和同步互斥锁不同的是，更新失败的线程并不会被阻塞，而是被告知这次由于竞争而导致的操作失败，但还可以再次尝试。</p>
<p>思路：</p>
<p>在大多数处理器的指令中，都会实现 CAS 相关的指令，这一条指令就可以完成<strong>比较并交换</strong>的操作，也正是由于这是一条（而不是多条）CPU 指令，所以 CAS 相关的指令是具备原子性的，这个组合操作在执行期间不会被打断，这样就能保证并发安全。由于这个原子性是由 CPU 保证的，所以无需我们程序员来操心。</p>
<p>CAS需要有3个操作数：内存值V，旧的预期值A，即将要更新的目标值B。CAS指令执行时，当且仅当内存值V与预期值A相等时，将内存值修改为B，否则就什么都不做。</p>
<p>我们对此展开描述一下：CAS 会提前假定当前内存值 V 应该等于值 A，而值 A 往往是之前读取到当时的内存值 V。在执行 CAS 时，如果发现当前的内存值 V 恰好是值 A 的话，那 CAS 就会把内存值 V 改成值 B，而值 B 往往是在拿到值 A 后，在值 A 的基础上经过计算而得到的。如果执行 CAS 时发现此时内存值 V 不等于值 A，则说明在刚才计算 B 的期间内，内存值已经被其他线程修改过了，那么本次 CAS 就不应该再修改了，可以避免多人同时修改导致出错。这就是 CAS 的主要思路和流程。</p>
<p>利用 CAS 实现的无锁算法，就像我们谈判的时候，用一种非常乐观的方式去协商，彼此之间很友好，这次没谈成，还可以重试。CAS 的思路和之前的互斥锁是两种完全不同的思路，如果是互斥锁，不存在协商机制，大家都会尝试抢占资源，如果抢到了，在操作完成前，会把这个资源牢牢的攥在自己的手里。当然，利用 CAS 和利用互斥锁，都可以保证并发安全，它们是实现同一目标的不同手段。</p>
<p>失败的线程可以重试、报错或者干脆跳过执行。举一个例子，在秒杀场景下，多个线程同时执行秒杀，只要有一个执行成功就够了，剩下的线程当发现自己 CAS 失败了，其实说明兄弟线程执行成功了，也就没有必要继续执行了，这就是跳过操作。所以业务逻辑不同，就会有不同的处理方法，但无论后续怎么处理，之前的那一次 CAS 操作是已经失败了的。</p>
<h3 id="什么是僵尸进程孤儿进程守护进程">什么是僵尸进程/孤儿进程/守护进程？</h3>
<p>僵尸进程：当子进程exit()退出之后，他的父进程没有通过wait()系统调用回收他的进程描述符的信息，该进程会继续停留在系统的进程表中，占用内核资源，这样的进程就是僵尸进程。解决：把父进程杀掉，这样就变成孤儿进程，由1号进程也就是init进程接管，最后回收。</p>
<p>孤儿进程：如果一个父进程忽然退出，它的子进程还在运行时，此时该进程就是一个孤儿进程。</p>
<p>守护进程：这是一种很特殊的进程，一般以d结尾，比如平时经常能看到的sshd，它会一直在后台运行去执行自己特定的任务。</p>
<h3 id="并发和并行的区别是什么">并发和并行的区别是什么？</h3>
<p>并发：多个进程轮流使用CPU，每个进程都分有一定的时间片，在用户的角度仿佛所有的程序在并行执行，但其实底层是按时间片轮流执行的。</p>
<p>并行：对于多核CPU，在同一时间，CPU的多个核可以并行的执行不同的指令，这是真正意义上实现了并行。</p>
<h3 id="一个进程可以创建多少线程">一个进程可以创建多少线程？</h3>
<p>这个问题跟两个东西有关系：</p>
<ul>
<li><strong>进程的虚拟内存空间上限</strong>，因为创建一个线程，操作系统需要为其分配一个栈空间，如果线程数量越多，所需的栈空间就要越大，那么虚拟内存就会占用的越多。</li>
<li><strong>系统参数限制</strong>，虽然 Linux 并没有内核参数来控制单个进程创建的最大线程个数，但是有系统级别的参数来控制整个系统的最大线程个数。</li>
</ul>
<p>我们先看看，在进程里创建一个线程需要消耗多少虚拟内存大小？执行 ulimit -a 这条命令，查看进程创建线程时默认分配的栈空间大小，比如我这台服务器默认分配给线程的栈空间大小为 8M。</p>
</div>
    <div class="post__footer">
      
        <span><a class="category" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span>




      

      
        <span><a class="tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">操作系统进程管理</a></span>




      
    </div>

    
  </div>


      </main>
    </div><footer class="footer footer__base">
  <ul class="footer__list">
    <li class="footer__item">
      &copy;
      
        CJC
        2022


      
    </li>
    
  </ul>
</footer>
  
  <script
    type="text/javascript"
    src="/js/medium-zoom.min.9c062c557275acbaba71f0c7cd4024da3e3cc825d248bc4b2130811b0965330b.js"
    integrity="sha256-nAYsVXJ1rLq6cfDHzUAk2j48yCXSSLxLITCBGwllMws="
    crossorigin="anonymous"
  ></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-5HQND29S4G"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag('js', new Date());
  gtag('config', 'G-5HQND29S4G');
</script>
</body>
</html>
