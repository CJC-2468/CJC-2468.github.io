<!DOCTYPE html>
<html
  dir="ltr"
  lang="en"
  data-theme=""
  class="html"
><head>
  <title>
    
      CJC
        |
        设计模式


      


    
  </title>

  
  <meta charset="utf-8" /><meta name="generator" content="Hugo 0.97.3" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="author" content="CJC" />
  <meta
    name="description"
    content="
      Integrity
Goodness
Passion
H O P E



    "
  />
  
  
    
    
    <link
      rel="stylesheet"
      href="/scss/main.min.5551757e3608c8c17519a404d0c78646f8b4ce68b04e5acc290a21597ce09467.css"
      integrity="sha256-VVF1fjYIyMF1GaQE0MeGRvi0zmiwTlrMKQohWXzglGc="
      crossorigin="anonymous"
      type="text/css"
    />

  

  
  <link
    rel="stylesheet"
    href="/css/markupHighlight.min.31b0a1f317f55c529a460897848c97436bb138b19c399b37de70d463a8bf6ed5.css"
    integrity="sha256-MbCh8xf1XFKaRgiXhIyXQ2uxOLGcOZs33nDUY6i/btU="
    crossorigin="anonymous"
    type="text/css"
  />
  
  
  <link
    rel="stylesheet"
    href="/fontawesome/css/fontawesome.min.69685904d5c2a0c6258d03c207b778c10466edf6cea928cc0164c376b0ad0930.css"
    integrity="sha256-aWhZBNXCoMYljQPCB7d4wQRm7fbOqSjMAWTDdrCtCTA="
    crossorigin="anonymous"
    type="text/css"
  />
  
  <link
    rel="stylesheet"
    href="/fontawesome/css/solid.min.6d585e78d28cce1200d39fb133c92ed83df01738da721d0f48fb6eac62d24e04.css"
    integrity="sha256-bVheeNKMzhIA05&#43;xM8ku2D3wFzjach0PSPturGLSTgQ="
    crossorigin="anonymous"
    type="text/css"
  />
  
  <link
    rel="stylesheet"
    href="/fontawesome/css/brands.min.6b00d96498d59caa0dbcf9b49d30d821915291f2ceb0e19248523c8607ff43fa.css"
    integrity="sha256-awDZZJjVnKoNvPm0nTDYIZFSkfLOsOGSSFI8hgf/Q/o="
    crossorigin="anonymous"
    type="text/css"
  />
  
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />

  <link rel="canonical" href="https://example.com/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" />

  
  
  
  
  <script
    type="text/javascript"
    src="/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js"
    integrity="sha256-&#43;RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI="
    crossorigin="anonymous"
  ></script>

  
    
    
    <script
      type="text/javascript"
      src="/js/anatole-theme-switcher.min.560a26330d27ff44a44e83b53cd07a95d4230a65930d31c5c76a8d481e5b35bf.js"
      integrity="sha256-VgomMw0n/0SkToO1PNB6ldQjCmWTDTHFx2qNSB5bNb8="
      crossorigin="anonymous"
    ></script>

  

  


  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="设计模式"/>
<meta name="twitter:description" content="设计模式能够帮助我们优化代码结构，让代码更优雅灵活。常见的设计模式有单例模式、工厂模式、装饰模式、策略模式、代理模式和观察者模式等。
设计模式概念 设计模式本身其实是一套优秀的设计经验的总结。在面向对象编程的时候，前人经历过很多实验和错误，之后总结出一套针对各种场景的设计经验，这些设计经验能够提高编码的可扩展性，可复用，可维护和灵活性。
设计模式的类型 共23种。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）
创建型模式 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。共5种。"/>



  
  <meta property="og:title" content="设计模式" />
<meta property="og:description" content="设计模式能够帮助我们优化代码结构，让代码更优雅灵活。常见的设计模式有单例模式、工厂模式、装饰模式、策略模式、代理模式和观察者模式等。
设计模式概念 设计模式本身其实是一套优秀的设计经验的总结。在面向对象编程的时候，前人经历过很多实验和错误，之后总结出一套针对各种场景的设计经验，这些设计经验能够提高编码的可扩展性，可复用，可维护和灵活性。
设计模式的类型 共23种。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）
创建型模式 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。共5种。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://example.com/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-04-21T12:22:40+08:00" />
<meta property="article:modified_time" content="2022-04-21T12:22:40+08:00" /><meta property="og:site_name" content="CJC&#39;s time&amp;space" />




  
  
  
  
  <script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "articleSection": "post",
        "name": "设计模式",
        "headline": "设计模式",
        "alternativeHeadline": "",
        "description": "
      
        设计模式能够帮助我们优化代码结构，让代码更优雅灵活。常见的设计模式有单例模式、工厂模式、装饰模式、策略模式、代理模式和观察者模式等。\n设计模式概念 设计模式本身其实是一套优秀的设计经验的总结。在面向对象编程的时候，前人经历过很多实验和错误，之后总结出一套针对各种场景的设计经验，这些设计经验能够提高编码的可扩展性，可复用，可维护和灵活性。\n设计模式的类型 共23种。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）\n创建型模式 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。共5种。


      


    ",
        "inLanguage": "en",
        "isFamilyFriendly": "true",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/example.com\/post\/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\/"
        },
        "author" : {
            "@type": "Person",
            "name": "CJC"
        },
        "creator" : {
            "@type": "Person",
            "name": "CJC"
        },
        "accountablePerson" : {
            "@type": "Person",
            "name": "CJC"
        },
        "copyrightHolder" : {
            "@type": "Person",
            "name": "CJC"
        },
        "copyrightYear" : "2022",
        "dateCreated": "2022-04-21T12:22:40.00Z",
        "datePublished": "2022-04-21T12:22:40.00Z",
        "dateModified": "2022-04-21T12:22:40.00Z",
        "publisher":{
            "@type":"Organization",
            "name": "CJC",
            "url": "https://example.com",
            "logo": {
                "@type": "ImageObject",
                "url": "https:\/\/example.comfavicon-32x32.png",
                "width":"32",
                "height":"32"
            }
        },
        "image": 
      [
      ]

    ,
        "url" : "https:\/\/example.com\/post\/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\/",
        "wordCount" : "424",
        "genre" : [ 
      
      "设计模式"

    ],
        "keywords" : [ ]
    }
  </script>



</head>
<body
    
      class="body theme--light"

    
  >
    <div class="wrapper">
      <aside
        
          class="wrapper__sidebar"

        
      ><div
  class="sidebar
    animated fadeInDown

  "
>
  <div class="sidebar__content">
    <div class="sidebar__introduction">
      <img
        class="sidebar__introduction-profileimage"
        src="/images/cat.jpeg"
        alt="profile picture"
      />
      
        <div class="sidebar__introduction-title">
          <a href="/">CJC&#39;s time&amp;space</a>
        </div>

      
      <div class="sidebar__introduction-description">
        <p>Integrity<br />Goodness<br />Passion<br />H O P E<br /></p>
      </div>
    </div>
    <ul class="sidebar__list">
      
        <li class="sidebar__list-item">
          <a href="https://github.com/CJC-2468" rel="me" aria-label="GitHub" title="GitHub">
            <i class="fab fa-github fa-2x" aria-hidden="true"></i>
          </a>
        </li>

      
        <li class="sidebar__list-item">
          <a href="mailto:jccheng2022@gmail.com" rel="me" aria-label="e-mail" title="e-mail">
            <i class="fas fa-envelope fa-2x" aria-hidden="true"></i>
          </a>
        </li>

      
        <li class="sidebar__list-item">
          <a href="#" rel="me" aria-label="instagram" title="instagram">
            <i class="fab fa-instagram fa-2x" aria-hidden="true"></i>
          </a>
        </li>

      
        <li class="sidebar__list-item">
          <a href="#" rel="me" aria-label="Linkedin" title="Linkedin">
            <i class="fab fa-linkedin fa-2x" aria-hidden="true"></i>
          </a>
        </li>

      
    </ul>
  </div><footer class="footer footer__sidebar">
  <ul class="footer__list">
    <li class="footer__item">
      &copy;
      
        CJC
        2022


      
    </li>
    
  </ul>
</footer>
  
  <script
    type="text/javascript"
    src="/js/medium-zoom.min.9c062c557275acbaba71f0c7cd4024da3e3cc825d248bc4b2130811b0965330b.js"
    integrity="sha256-nAYsVXJ1rLq6cfDHzUAk2j48yCXSSLxLITCBGwllMws="
    crossorigin="anonymous"
  ></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-5HQND29S4G"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag('js', new Date());
  gtag('config', 'G-5HQND29S4G');
</script>
</div>
</aside>
      <main
        
          class="wrapper__main"

        
      >
        <header class="header"><div
  class="
    animated fadeInDown

  "
>
  <a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false">
    <span aria-hidden="true" class="navbar-burger__line"></span>
    <span aria-hidden="true" class="navbar-burger__line"></span>
    <span aria-hidden="true" class="navbar-burger__line"></span>
  </a>
  <nav class="nav">
    <ul class="nav__list" id="navMenu">
      
      
        
        <li class="nav__list-item">
          <a
            
            href="/"
            
            title=""
            >Home</a
          >
        </li>

      
        
        <li class="nav__list-item">
          <a
            
            href="/post/"
            
            title=""
            >目录</a
          >
        </li>

      
        
        <li class="nav__list-item">
          <a
            
            href="/categories/"
            
            title=""
            >分类</a
          >
        </li>

      
        
        <li class="nav__list-item">
          <a
            
            href="/tags/"
            
            title=""
            >标签</a
          >
        </li>

      
        
        <li class="nav__list-item">
          <a
            
            href="/wikif"
            
            title=""
            >个人探索</a
          >
        </li>

      
    </ul>
    <ul class="nav__list nav__list--end">
      
      
        <li class="nav__list-item">
          <div class="themeswitch">
            <a title="Switch Theme">
              <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a>
          </div>
        </li>

      
    </ul>
  </nav>
</div>
</header>
  <div
    class="post 
      animated fadeInDown

    "
  >
    
    <div class="post__content">
      <h1>设计模式</h1>
      
        <ul class="post__meta">
          <li class="post__meta-item">
            <em class="fas fa-calendar-day post__meta-icon"></em>
            <span class="post__meta-text"
              >
                Thu, Apr 21, 2022


              
            </span>
          </li>
          <li class="post__meta-item">
            <em class="fas fa-stopwatch post__meta-icon"></em>
            <span class="post__meta-text">2-minute read</span>
          </li>
        </ul>

      <p>设计模式能够帮助我们优化代码结构，让代码更优雅灵活。常见的设计模式有单例模式、工厂模式、装饰模式、策略模式、代理模式和观察者模式等。</p>
<h1 id="设计模式概念">设计模式概念</h1>
<p>设计模式本身其实是一套优秀的设计经验的总结。在面向对象编程的时候，前人经历过很多实验和错误，之后总结出一套针对各种场景的设计经验，这些设计经验能够提高编码的可扩展性，可复用，可维护和灵活性。</p>
<h1 id="设计模式的类型">设计模式的类型</h1>
<p>共23种。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）</p>
<p><strong>创建型模式</strong>
这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。共5种。</p>
<ul>
<li>工厂模式（Factory Pattern）</li>
<li>抽象工厂模式（Abstract Factory Pattern）</li>
<li>单例模式（Singleton Pattern）</li>
<li>建造者模式（Builder Pattern）</li>
<li>原型模式（Prototype Pattern）</li>
</ul>
<p><strong>结构型模式</strong>
这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。共8种。</p>
<ul>
<li>适配器模式（Adapter Pattern）</li>
<li>桥接模式（Bridge Pattern）</li>
<li>过滤器模式（Filter、Criteria Pattern）</li>
<li>组合模式（Composite Pattern）</li>
<li>装饰器模式（Decorator Pattern）</li>
<li>外观模式（Facade Pattern）</li>
<li>享元模式（Flyweight Pattern）</li>
<li>代理模式（Proxy Pattern）</li>
</ul>
<p><strong>行为型模式</strong>
这些设计模式特别关注对象之间的通信。共12种。</p>
<ul>
<li>责任链模式（Chain of Responsibility Pattern）</li>
<li>命令模式（Command Pattern）</li>
<li>解释器模式（Interpreter Pattern）</li>
<li>迭代器模式（Iterator Pattern）</li>
<li>中介者模式（Mediator Pattern）</li>
<li>备忘录模式（Memento Pattern）</li>
<li>观察者模式（Observer Pattern）</li>
<li>状态模式（State Pattern）</li>
<li>空对象模式（Null Object Pattern）</li>
<li>策略模式（Strategy Pattern）</li>
<li>模板模式（Template Pattern）</li>
<li>访问者模式（Visitor Pattern）</li>
</ul>
<h1 id="设计模式的原则">设计模式的原则</h1>
<p><strong>1、开闭原则（Open Close Principle）</strong></p>
<p>开闭原则的意思是：软件实体（类，模块，函数）可扩展，但是不可修改。面对需求，在程序需要进行拓展的时候，不能去修改原有的代码，而是只增加新的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。举例子，电脑内存不够的话，只要插槽够就能继续加，这样更方便，换内存就比较麻烦了。</p>
<p><strong>2、单一职责原则</strong></p>
<p>就一个类而言，应该仅有一个引起它变化的原因。拿电脑举例，内存坏了，那我们应该换内存，而不应该涉及CPU，这就是因为他们的职责都是单一明确的。</p>
<p><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong></p>
<p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不是依赖于具体实现。高层不应该依赖于低层，两者都应该依赖抽象。</p>
<p><strong>4、里氏代换原则（Liskov Substitution Principle）</strong></p>
<p>子类必须可以替换父类。 正式因为这个原则，才让继承复用成为可能，只有子类可以替换父类的情况下软件的功能不受影响时，父类才能真正被复用，而子类也能在父类基础上增加新的行为。正式有了这个原则，才让开闭原则有了可能。</p>
<p><strong>5、迪米特法则，又称最少知道原则（Demeter Principle）</strong></p>
<p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<p><strong>6、合成复用原则（Composite Reuse Principle）</strong></p>
<p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p>
<p><strong>7、接口隔离原则（Interface Segregation Principle）</strong></p>
<p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p>
<p>注：面向对象的高内聚低耦合，其实可以叫电脑里的易插拔。</p>
<h1 id="单例模式">单例模式</h1>
<h2 id="基本特点">基本特点</h2>
<p>单例模式（Singleton）的目的是为了保证某个类有且仅有一个实例，并提供一个访问它的全局访问点。</p>
<p>主要解决：一个全局使用的类频繁地创建与销毁。为了控制实例数目，节省系统资源的时候。判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p>
<p>在golang中，</p>
<p>1.命名以小写字母开头，对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 private ）</p>
<p>2.提供一个能够访问这个全局唯一实例的函数GetInstance() *singleton</p>
<p>3.在GetInstance()中，先做判断是否已形成实例，如果已形成则直接返回，否则创建实例。</p>
<h2 id="常见的错误">常见的错误</h2>
<p>有一些错误是很常见的，比如不考虑并发安全的单例模式。就像下面的示例代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">singleton</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">singleton</span> <span class="kd">struct</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">instance</span> <span class="o">*</span><span class="nx">singleton</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">GetInstance</span><span class="p">()</span> <span class="o">*</span><span class="nx">singleton</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">instance</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">instance</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">singleton</span><span class="p">{}</span>   <span class="c1">// 不是并发安全的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">instance</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在上述情况下，多个goroutine可以执行第一个检查，并且它们都将创建该<code>singleton</code>类型的实例并相互覆盖。无法保证它将在此处返回哪个实例，并且对该实例的其他进一步操作可能与开发人员的期望不一致。</p>
<h2 id="加锁">加锁</h2>
<p>使用下面的代码确实能解决并发安全问题，通过加锁把对该函数的并发调用变成了串行。在实例已经创建的情况下，我们应该简单地返回缓存的单例实例。在高度并发的代码基础上，这可能会产生瓶颈，因为一次只有一个goroutine可以获得单例实例。所以这样还是不行。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">singleton</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">singleton</span> <span class="kd">struct</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">instance</span> <span class="o">*</span><span class="nx">singleton</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">mu</span> <span class="nx">Sync</span><span class="p">.</span><span class="nx">Mutex</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">GetInstance</span><span class="p">()</span> <span class="o">*</span><span class="nx">singleton</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>                    <span class="c1">// 如果实例存在没有必要加锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">defer</span> <span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">instance</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">instance</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">singleton</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">instance</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="go语言惯用的单例模式">Go语言惯用的单例模式</h2>
<p>我们在标准库<code>sync</code>中找到了<code>Once</code>类型。它能保证某个操作仅且只执行一次。该实现利用<code>sync.Once</code>类型去同步对<code>GetInstance()</code>的访问，并确保我们的类型仅被初始化一次。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">singleton</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">instance</span> <span class="o">*</span><span class="nx">singleton</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">once</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">getInstance</span><span class="p">()</span> <span class="o">*</span><span class="nx">singleton</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">once</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">instance</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">singleton</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">instance</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h1 id="工厂模式">工厂模式</h1>
<h2 id="简单工厂模式">简单工厂模式</h2>
<p>简单工厂模式（Simple Factory Pattern）：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态（static）方法，因此简单工厂模式又被称为静态工厂方法（Static Factory Method）模式，它属于创建型模式。</p>
<img src="https://cjcpicgoimg.oss-cn-beijing.aliyuncs.com/img/20220605224608.png" style="zoom:50%;" />
<p>代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Product</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">used</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ProductX</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">px</span> <span class="nx">ProductX</span><span class="p">)</span> <span class="nf">used</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;the productX is used!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ProductY</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">py</span> <span class="nx">ProductY</span><span class="p">)</span> <span class="nf">used</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;the productY is used!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Factory</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">Factory</span><span class="p">)</span> <span class="nf">creatProduct</span><span class="p">(</span><span class="nx">t</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">Product</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">switch</span> <span class="nx">t</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="s">&#34;productX&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">ProductX</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="s">&#34;productY&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">ProductY</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">f</span> <span class="o">:=</span> <span class="nx">Factory</span><span class="p">{}</span><span class="c1">//建个场子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">px</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">.</span><span class="nf">creatProduct</span><span class="p">(</span><span class="s">&#34;productX&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">px</span><span class="p">.</span><span class="nf">used</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">py</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">.</span><span class="nf">creatProduct</span><span class="p">(</span><span class="s">&#34;productY&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">py</span><span class="p">.</span><span class="nf">used</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>适用场景：对于产品种类相对较少的情况，考虑使用简单工厂模式。</p>
<p>优点：客户端不需要关注创建实例的逻辑，只需提供传入工厂的参数。</p>
<p>缺点：如果要增加新产品，就需要修改工厂类的判断逻辑，<strong>违背开闭原则</strong>，且产品多的话会使工厂类比较复杂。</p>
<p>在一些实际的项目中，为了避免简单工厂模式带来的问题，我们可以考虑使用工厂方法模式。</p>
<h2 id="工厂方法模式">工厂方法模式</h2>
<p>工厂方法模式（Factory Method Pattern）又称为工厂模式，也叫多态工厂（Polymorphic Factory）模式。在工厂模式中，唯一的一个工厂控制着 所有产品的实例化，而 工厂方法模式中包括一个工厂接口，我们可以动态的实现多种工厂，达到扩展的目的。</p>
<img src="https://cjcpicgoimg.oss-cn-beijing.aliyuncs.com/img/20220605224732.png" style="zoom:50%;" />
<p>简单工厂模式和工厂方法模式区别：</p>
<ul>
<li>简单工厂需要:
<ol>
<li>工厂结构体</li>
<li>产品接口</li>
<li>产品结构体</li>
</ol>
</li>
<li>工厂方法需要:
<ol>
<li>工厂接口</li>
<li>工厂结构体</li>
<li>产品接口</li>
<li>产品结构体</li>
</ol>
</li>
</ul>
<p>在 简单工模式中，如果我们需要实例化一个产品，那么就要向工厂中传入一个参数获取对应对象，如果要增加一种产品，就要在工厂中修改创建产品的函数，违背了开闭原则。而在 工厂方法模式 中，我们可以通过实现工厂接口，创建多种工厂，将对象创建由一个工厂负责所有具体类的实例化，变成由多个工厂来负责对具体类的实例化。</p>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Product</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">used</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ProductX</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">px</span> <span class="nx">ProductX</span><span class="p">)</span> <span class="nf">used</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;the productX is used!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ProductY</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">py</span> <span class="nx">ProductY</span><span class="p">)</span> <span class="nf">used</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;the productY is used!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Factory</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">produce</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="nx">Product</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Factory1</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">Factory1</span><span class="p">)</span> <span class="nf">produce</span><span class="p">()</span> <span class="nx">Product</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">ProductX</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Factory2</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">Factory2</span><span class="p">)</span> <span class="nf">produce</span><span class="p">()</span> <span class="nx">Product</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">ProductY</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">f1</span> <span class="o">:=</span> <span class="nx">Factory1</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">px</span> <span class="o">:=</span> <span class="nx">f1</span><span class="p">.</span><span class="nf">produce</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">px</span><span class="p">.</span><span class="nf">used</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">f2</span> <span class="o">:=</span> <span class="nx">Factory2</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">py</span> <span class="o">:=</span> <span class="nx">f2</span><span class="p">.</span><span class="nf">produce</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">py</span><span class="p">.</span><span class="nf">used</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>场景：客户只知道创建产品的工厂名，而不知道具体的产品名。</p>
<p>优点：</p>
<ul>
<li>在系统中加入新产品时，只需要添加一个具体工厂和具体产品。系统的可扩展性强，更加符合 “开闭原则”。</li>
<li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。</li>
</ul>
<p>缺点：</p>
<ul>
<li>在添加新产品时，需要编写新的具体产品类和具体工厂类，系统中类的个数将成对增加，增加了系统的复杂度。</li>
<li>一个具体工厂只能创建一种具体产品。</li>
</ul>
<p>这里我们知道在工厂方法模式中，一个具体工厂只能创建一种具体产品。很明显这限制该模式的使用场景，那么我们是否能突破该限制呢？答案是可以的。下面我们来介绍抽象工厂模式。</p>
<h2 id="抽象工厂模式">抽象工厂模式</h2>
<p>基本特点</p>
<p>抽象工厂模式（Abstract Factory Pattern），提供一个创建一组相关或相互依赖对象的接口，而无须指定它们具体的类。</p>
<p>在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法也具有唯一性，一般情况下，一个具体工厂中只有一个工厂方法。 但是有时候我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象。</p>
<img src="https://cjcpicgoimg.oss-cn-beijing.aliyuncs.com/img/20220605224516.png" style="zoom:50%;" />
<p>适用场景:</p>
<ul>
<li>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。</li>
<li>系统一次只可能消费其中某一族产品，即同族的产品一起使用。</li>
</ul>
<img src="https://cjcpicgoimg.oss-cn-beijing.aliyuncs.com/img/20220605230240.png" style="zoom:50%;" />
<p>优点:更换产品族的时候很方便，比如从海尔系列更换道TCL。只用改动很少量的代码就可以。抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则。</p>
<p>缺点：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度。</p>
<p>抽象工厂模式与工厂方法模式最大的区别在于：与工厂方法模式不同的是，工厂方法模式中的工厂只生产单一的产品，而抽象工厂模式中的工厂生产多个产品，工厂方法和抽象工厂属于创建型模式，该模式用于描述 “怎样创建对象”，它的主要特点是 “将对象的创建与使用分离”。</p>
</div>
    <div class="post__footer">
      
        <span><a class="category" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></span>




      

      
    </div>

    
  </div>


      </main>
    </div><footer class="footer footer__base">
  <ul class="footer__list">
    <li class="footer__item">
      &copy;
      
        CJC
        2022


      
    </li>
    
  </ul>
</footer>
  
  <script
    type="text/javascript"
    src="/js/medium-zoom.min.9c062c557275acbaba71f0c7cd4024da3e3cc825d248bc4b2130811b0965330b.js"
    integrity="sha256-nAYsVXJ1rLq6cfDHzUAk2j48yCXSSLxLITCBGwllMws="
    crossorigin="anonymous"
  ></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-5HQND29S4G"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag('js', new Date());
  gtag('config', 'G-5HQND29S4G');
</script>
</body>
</html>
