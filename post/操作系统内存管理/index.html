<!DOCTYPE html>
<html
  dir="ltr"
  lang="en"
  data-theme=""
  class="html"
><head>
  <title>
    
      CJC
        |
        操作系统内存管理


      


    
  </title>

  
  <meta charset="utf-8" /><meta name="generator" content="Hugo 0.97.3" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="author" content="CJC" />
  <meta
    name="description"
    content="
      Integrity
Goodness
Passion
H O P E



    "
  />
  
  
    
    
    <link
      rel="stylesheet"
      href="/scss/main.min.5551757e3608c8c17519a404d0c78646f8b4ce68b04e5acc290a21597ce09467.css"
      integrity="sha256-VVF1fjYIyMF1GaQE0MeGRvi0zmiwTlrMKQohWXzglGc="
      crossorigin="anonymous"
      type="text/css"
    />

  

  
  <link
    rel="stylesheet"
    href="/css/markupHighlight.min.31b0a1f317f55c529a460897848c97436bb138b19c399b37de70d463a8bf6ed5.css"
    integrity="sha256-MbCh8xf1XFKaRgiXhIyXQ2uxOLGcOZs33nDUY6i/btU="
    crossorigin="anonymous"
    type="text/css"
  />
  
  
  <link
    rel="stylesheet"
    href="/fontawesome/css/fontawesome.min.69685904d5c2a0c6258d03c207b778c10466edf6cea928cc0164c376b0ad0930.css"
    integrity="sha256-aWhZBNXCoMYljQPCB7d4wQRm7fbOqSjMAWTDdrCtCTA="
    crossorigin="anonymous"
    type="text/css"
  />
  
  <link
    rel="stylesheet"
    href="/fontawesome/css/solid.min.6d585e78d28cce1200d39fb133c92ed83df01738da721d0f48fb6eac62d24e04.css"
    integrity="sha256-bVheeNKMzhIA05&#43;xM8ku2D3wFzjach0PSPturGLSTgQ="
    crossorigin="anonymous"
    type="text/css"
  />
  
  <link
    rel="stylesheet"
    href="/fontawesome/css/brands.min.6b00d96498d59caa0dbcf9b49d30d821915291f2ceb0e19248523c8607ff43fa.css"
    integrity="sha256-awDZZJjVnKoNvPm0nTDYIZFSkfLOsOGSSFI8hgf/Q/o="
    crossorigin="anonymous"
    type="text/css"
  />
  
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />

  <link rel="canonical" href="https://example.com/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" />

  
  
  
  
  <script
    type="text/javascript"
    src="/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js"
    integrity="sha256-&#43;RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI="
    crossorigin="anonymous"
  ></script>

  
    
    
    <script
      type="text/javascript"
      src="/js/anatole-theme-switcher.min.560a26330d27ff44a44e83b53cd07a95d4230a65930d31c5c76a8d481e5b35bf.js"
      integrity="sha256-VgomMw0n/0SkToO1PNB6ldQjCmWTDTHFx2qNSB5bNb8="
      crossorigin="anonymous"
    ></script>

  

  


  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="操作系统内存管理"/>
<meta name="twitter:description" content="内存管理 什么是逻辑地址和物理地址？ 我们编程一般只有可能和逻辑地址打交道，比如在 GO 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。
进程地址空间有哪些划分？ 虚拟地址空间的内部又被分为 内核空间 和 用户空间 两部分。"/>



  
  <meta property="og:title" content="操作系统内存管理" />
<meta property="og:description" content="内存管理 什么是逻辑地址和物理地址？ 我们编程一般只有可能和逻辑地址打交道，比如在 GO 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。
进程地址空间有哪些划分？ 虚拟地址空间的内部又被分为 内核空间 和 用户空间 两部分。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://example.com/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-05-07T19:07:10+08:00" />
<meta property="article:modified_time" content="2022-05-07T19:07:10+08:00" /><meta property="og:site_name" content="CJC&#39;s time&amp;space" />




  
  
  
  
  <script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "articleSection": "post",
        "name": "操作系统内存管理",
        "headline": "操作系统内存管理",
        "alternativeHeadline": "",
        "description": "
      
        内存管理 什么是逻辑地址和物理地址？ 我们编程一般只有可能和逻辑地址打交道，比如在 GO 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。\n进程地址空间有哪些划分？ 虚拟地址空间的内部又被分为 内核空间 和 用户空间 两部分。


      


    ",
        "inLanguage": "en",
        "isFamilyFriendly": "true",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/example.com\/post\/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86\/"
        },
        "author" : {
            "@type": "Person",
            "name": "CJC"
        },
        "creator" : {
            "@type": "Person",
            "name": "CJC"
        },
        "accountablePerson" : {
            "@type": "Person",
            "name": "CJC"
        },
        "copyrightHolder" : {
            "@type": "Person",
            "name": "CJC"
        },
        "copyrightYear" : "2022",
        "dateCreated": "2022-05-07T19:07:10.00Z",
        "datePublished": "2022-05-07T19:07:10.00Z",
        "dateModified": "2022-05-07T19:07:10.00Z",
        "publisher":{
            "@type":"Organization",
            "name": "CJC",
            "url": "https://example.com",
            "logo": {
                "@type": "ImageObject",
                "url": "https:\/\/example.comfavicon-32x32.png",
                "width":"32",
                "height":"32"
            }
        },
        "image": 
      [
      ]

    ,
        "url" : "https:\/\/example.com\/post\/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86\/",
        "wordCount" : "127",
        "genre" : [ 
      
      "操作系统"

    ],
        "keywords" : [ 
      
      "操作系统内存管理"

    ]
    }
  </script>



</head>
<body
    
      class="body theme--light"

    
  >
    <div class="wrapper">
      <aside
        
          class="wrapper__sidebar"

        
      ><div
  class="sidebar
    animated fadeInDown

  "
>
  <div class="sidebar__content">
    <div class="sidebar__introduction">
      <img
        class="sidebar__introduction-profileimage"
        src="/images/cat.jpeg"
        alt="profile picture"
      />
      
        <div class="sidebar__introduction-title">
          <a href="/">CJC&#39;s time&amp;space</a>
        </div>

      
      <div class="sidebar__introduction-description">
        <p>Integrity<br />Goodness<br />Passion<br />H O P E<br /></p>
      </div>
    </div>
    <ul class="sidebar__list">
      
        <li class="sidebar__list-item">
          <a href="https://github.com/CJC-2468" rel="me" aria-label="GitHub" title="GitHub">
            <i class="fab fa-github fa-2x" aria-hidden="true"></i>
          </a>
        </li>

      
        <li class="sidebar__list-item">
          <a href="mailto:jccheng2022@gmail.com" rel="me" aria-label="e-mail" title="e-mail">
            <i class="fas fa-envelope fa-2x" aria-hidden="true"></i>
          </a>
        </li>

      
        <li class="sidebar__list-item">
          <a href="#" rel="me" aria-label="instagram" title="instagram">
            <i class="fab fa-instagram fa-2x" aria-hidden="true"></i>
          </a>
        </li>

      
        <li class="sidebar__list-item">
          <a href="#" rel="me" aria-label="Linkedin" title="Linkedin">
            <i class="fab fa-linkedin fa-2x" aria-hidden="true"></i>
          </a>
        </li>

      
    </ul>
  </div><footer class="footer footer__sidebar">
  <ul class="footer__list">
    <li class="footer__item">
      &copy;
      
        CJC
        2022


      
    </li>
    
  </ul>
</footer>
  
  <script
    type="text/javascript"
    src="/js/medium-zoom.min.9c062c557275acbaba71f0c7cd4024da3e3cc825d248bc4b2130811b0965330b.js"
    integrity="sha256-nAYsVXJ1rLq6cfDHzUAk2j48yCXSSLxLITCBGwllMws="
    crossorigin="anonymous"
  ></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-5HQND29S4G"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag('js', new Date());
  gtag('config', 'G-5HQND29S4G');
</script>
</div>
</aside>
      <main
        
          class="wrapper__main"

        
      >
        <header class="header"><div
  class="
    animated fadeInDown

  "
>
  <a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false">
    <span aria-hidden="true" class="navbar-burger__line"></span>
    <span aria-hidden="true" class="navbar-burger__line"></span>
    <span aria-hidden="true" class="navbar-burger__line"></span>
  </a>
  <nav class="nav">
    <ul class="nav__list" id="navMenu">
      
      
        
        <li class="nav__list-item">
          <a
            
            href="/"
            
            title=""
            >Home</a
          >
        </li>

      
        
        <li class="nav__list-item">
          <a
            
            href="/post/"
            
            title=""
            >目录</a
          >
        </li>

      
        
        <li class="nav__list-item">
          <a
            
            href="/categories/"
            
            title=""
            >分类</a
          >
        </li>

      
        
        <li class="nav__list-item">
          <a
            
            href="/tags/"
            
            title=""
            >标签</a
          >
        </li>

      
        
        <li class="nav__list-item">
          <a
            
            href="/wikif"
            
            title=""
            >个人探索</a
          >
        </li>

      
    </ul>
    <ul class="nav__list nav__list--end">
      
      
        <li class="nav__list-item">
          <div class="themeswitch">
            <a title="Switch Theme">
              <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a>
          </div>
        </li>

      
    </ul>
  </nav>
</div>
</header>
  <div
    class="post 
      animated fadeInDown

    "
  >
    
    <div class="post__content">
      <h1>操作系统内存管理</h1>
      
        <ul class="post__meta">
          <li class="post__meta-item">
            <em class="fas fa-calendar-day post__meta-icon"></em>
            <span class="post__meta-text"
              >
                Sat, May 7, 2022


              
            </span>
          </li>
          <li class="post__meta-item">
            <em class="fas fa-stopwatch post__meta-icon"></em>
            <span class="post__meta-text">One-minute read</span>
          </li>
        </ul>

      <h2 id="内存管理">内存管理</h2>
<h3 id="什么是逻辑地址和物理地址">什么是逻辑地址和物理地址？</h3>
<p>我们编程一般只有可能和逻辑地址打交道，比如在 GO 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。</p>
<h3 id="进程地址空间有哪些划分">进程地址空间有哪些划分？</h3>
<p>虚拟地址空间的内部又被分为 内核空间 和 用户空间 两部分。</p>
<p>用户空间的代码只能访问一个局部的内存空间，而内核空间的代码可以访问所有内存空间。当程序使用用户空间时，我们常说该程序在用户态执行，而当程序使内核空间时，程序则在内核态执行。</p>
<h3 id="cpu寻址了解吗为什么需要虚拟地址空间">CPU寻址了解吗？为什么需要虚拟地址空间？</h3>
<p>现代处理器使用的是一种称为 <strong>虚拟寻址(Virtual Addressing)</strong> 的寻址方式。</p>
<p>单片机的 CPU 是直接操作内存的「物理地址」,如果直接使用物理地址，那么当有多个程序同时使用某个物理地址的话，就会前后覆盖出问题.</p>
<p>解决方案是用虚拟地址，把每个进程的地址隔离开，每个程序都会分配到一段连续的虚拟地址空间，但实际物理地址可以是不相邻的，虚拟地址空间可以大于实际物理地址空间。（隔离，连续）</p>
<p>使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存，由CPU 中含有一个被称为 <strong>内存管理单元（Memory Management Unit, MMU）</strong> 的硬件来实现。</p>
<h3 id="操作系统是如何管理虚拟地址与物理地址之间的关系">操作系统是如何管理虚拟地址与物理地址之间的关系？</h3>
<p>主要有两种方式，分别是<strong>内存分段和内存分页</strong>，分段是比较早提出的，我们先来看看内存分段。</p>
<h3 id="操作系统的内存管理主要是做什么"><strong>操作系统的内存管理主要是做什么？</strong></h3>
<ul>
<li>主要负责内存的分配与回收</li>
<li>虚拟地址转换物理地址</li>
</ul>
<h3 id="内存管理方式有哪几种">内存管理方式有哪几种？</h3>
<p><strong>段式管理</strong> ： 段式管理的出现是比较早的。程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的逻辑意义的，所以就用分段的形式把这些段分离出来。 段式管理通过段表映射逻辑地址和物理地址。</p>
<p>缺点是存在外部和内部的<strong>内存碎片</strong>。这里的内存碎片的问题共有两处地方：</p>
<ul>
<li>外部内存碎片，也就是产生了多个不连续的小物理内存，导致新的程序无法被装载；</li>
<li>内部内存碎片，程序所有的内存都被装载到了物理内存，但是这个程序有部分的内存可能并不是很常使用，这也会导致内存的浪费；</li>
</ul>
<p>解决<strong>外部内存碎片</strong>的问题就是<strong>内存交换</strong>。这个内存交换空间，在 Linux 系统里，也就是我们常看到的 Swap 空间，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。但是<strong>内存交换效率低</strong>，因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。</p>
<p><strong>页式管理</strong> ：把内存分为大小相等且固定的一页一页的形式，页较小，默认4kb，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。页表是存储在内存里的，<strong>内存管理单元</strong> （<em>MMU</em>）就做将虚拟内存地址转换成物理地址的工作。（linux用的就是页式管理，但是由于intel历史原因不得不涉及段，但段式映射的过程实际上作用不大。）</p>
<p>由于内存空间都是预先划分好的，也就不会像分段会产生间隙非常小的内存，这正是分段会产生内存碎片的原因。而采用了分页，那么释放的内存都是<strong>以页为单位释放</strong>的，也就不会产生无法给进程使用的小内存。</p>
<p>如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面暂时写在硬盘上，称为<strong>换出</strong>（<em>Swap Out</em>）。一旦需要的时候，再加载进来，称为<strong>换入</strong>（<em>Swap In</em>）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，<strong>内存交换的效率就相对比较高。</strong></p>
<img src="https://cjcpicgoimg.oss-cn-beijing.aliyuncs.com/img/20220505221941.png" style="zoom:50%;" />
<p>更进一步地，分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是**只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。**也就是请求分页。</p>
<p><strong>段页式管理</strong>：段页式管理结合了段式管理和页式管理的优点。简单来说就是把主存先分成若干段，每个段又分成若干页.</p>
<h3 id="页表管理机制中会遇到什么问题怎么解决什么是快表和多级页表">页表管理机制中会遇到什么问题？怎么解决？什么是快表和多级页表？</h3>
<p>问题（时间和空间）：1.虚拟地址到物理地址转换要快，怎么解决？  2.虚拟地址空间大，页表也会很大，怎么解决？</p>
<p><strong>时间上</strong>：为了加快虚拟地址到物理地址的转换速度，基于局部性原理思想引入了<strong>快表</strong>。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</p>
<img src="https://cjcpicgoimg.oss-cn-beijing.aliyuncs.com/img/20220505223521.png" style="zoom:50%;" />
<p><strong>空间上</strong>：因为操作系统是可以同时运行非常多的进程的，那这不就意味着页表会非常的庞大。</p>
<p>在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB，那么整个 4GB 空间的映射就需要有 <code>4MB</code> 的内存来存储页表。如果有100个进程就很可怕了，如果是64位的话，就更大了。</p>
<p>解决：引入<strong>多级页表</strong>的主要目的是为了解决空间上的问题，避免把全部页表一直放在内存中占用过多空间，我们可以把一级页表放进内存，二级页表只有访问到需要的时候再加载，引入了层次结构会加大时间开销。但是利用快表可以很好的把这个副作用抵消掉。</p>
<p><strong>页表一定要覆盖全部虚拟地址空间，不分级的页表就需要有 100 多万个页表项来映射，而二级分页则只需要 1024 个页表项</strong>（此时一级页表覆盖到了全部虚拟地址空间，二级页表在需要时创建）。</p>
<img src="https://cjcpicgoimg.oss-cn-beijing.aliyuncs.com/img/20220505223608.png" style="zoom:50%;" />
<h3 id="分段和分页机制的共同点和区别">分段和分页机制的共同点和区别？</h3>
<p>共同点：分页机制和分段机制都是为了提高内存利用率，减少内存碎片。</p>
<p>区别：</p>
<ul>
<li>页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。</li>
<li>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。</li>
</ul>
<h3 id="用户虚拟空间划分">用户虚拟空间划分？</h3>
<img src="https://cjcpicgoimg.oss-cn-beijing.aliyuncs.com/img/20220505224907.png" style="zoom:50%;" />
<p>通过这张图你可以看到，用户空间内存，从<strong>低到高</strong>分别是 6 种不同的内存段：</p>
<ul>
<li>程序文件段（.text），包括二进制可执行代码；</li>
<li>已初始化数据段（.data），包括静态常量；</li>
<li>未初始化数据段（.bss），包括未初始化的静态变量；</li>
<li>堆段，包括动态分配的内存，从低地址开始向上增长；</li>
<li>文件映射段，包括动态库、共享内存等，从低地址开始向上增长</li>
<li>栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 <code>8 MB</code>。当然系统也提供了参数，以便我们自定义大小；</li>
</ul>
<p>在这 7 个内存段中，堆和文件映射段的内存是动态分配的。</p>
<h3 id="什么是虚拟内存">什么是虚拟内存？</h3>
<p>当我们想运行的软件占用的内存超过实际的物理内存时，如果没有虚拟内存就的话，就没有办法运行了，有了虚拟内存以后，我们就可以实现让程序拥有超过实际物理内存的内存空间，虚拟内存可以使用硬盘空间来虚拟出一部分内存空间让软件去用。另一方面是虚拟内存可以让每个软件任务自己有一个连续完整的地址空间，而实际上它的地址空间可能有一部分在内存，有一部分在硬盘，所以还需要进行数据的换入和换出。</p>
<h3 id="什么是局部性原理">什么是局部性原理？</h3>
<p>局部性原理是虚拟内存中一个很重要的概念，意思就是说，程序的执行会呈现出局部性规律，在一段时间内，程序的执行局限于某一小部分，程序访问的存储空间也是局限于某一个区域。</p>
<p>局部性原理有两方面：</p>
<p><strong>时间局部性</strong> ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</p>
<p><strong>空间局部性</strong> ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</p>
<p>时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。</p>
<h3 id="虚拟内存技术如何实现">虚拟内存技术如何实现？</h3>
<p><strong>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。</strong> 虚拟内存的实现有以下三种方式：</p>
<p><strong>请求分页存储管理</strong> ：建立在分页内存管理之上，为了支持虚拟内存功能而增加了 <strong>请求调页</strong> 和<strong>页面置换</strong>功能。这个比较常用。在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</p>
<p><strong>请求分段存储管理</strong> ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</p>
<p><strong>请求段页式存储管理</strong></p>
<p><strong>这里多说一下？很多人容易搞混请求分页与分页存储管理，两者有何不同呢？</strong></p>
<p>请求分页存储管理建立在分页管理之上。它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。</p>
<p>不管是上面那种实现方式，我们一般都需要：</p>
<ol>
<li><strong>一定容量的内存和外存</strong>：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；</li>
<li><strong>缺页中断</strong>：如果<strong>需执行的指令或访问的数据尚未在内存</strong>（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段调入到内存，然后继续执行程序；</li>
<li><strong>虚拟地址空间</strong> ：逻辑地址到物理地址的变换，同时让一个进程有完整的虚拟地址空间。</li>
</ol>
</div>
    <div class="post__footer">
      
        <span><a class="category" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span>




      

      
        <span><a class="tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">操作系统内存管理</a></span>




      
    </div>

    
  </div>


      </main>
    </div><footer class="footer footer__base">
  <ul class="footer__list">
    <li class="footer__item">
      &copy;
      
        CJC
        2022


      
    </li>
    
  </ul>
</footer>
  
  <script
    type="text/javascript"
    src="/js/medium-zoom.min.9c062c557275acbaba71f0c7cd4024da3e3cc825d248bc4b2130811b0965330b.js"
    integrity="sha256-nAYsVXJ1rLq6cfDHzUAk2j48yCXSSLxLITCBGwllMws="
    crossorigin="anonymous"
  ></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-5HQND29S4G"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag('js', new Date());
  gtag('config', 'G-5HQND29S4G');
</script>
</body>
</html>
