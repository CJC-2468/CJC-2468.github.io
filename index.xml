<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <link>https://example.com/</link>
    <description>Recent content on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 07 May 2022 19:16:44 +0800</lastBuildDate><atom:link href="https://example.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>操作系统基本命令</title>
      <link>https://example.com/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Sat, 07 May 2022 19:16:44 +0800</pubDate>
      
      <guid>https://example.com/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</guid>
      
        <description>Linux基本命令 linux文本三剑客 awk、grep、sed是linux操作文本的三大利器，合称文本三剑客，也是必须掌握的linux命令之一。三者的功能都是处理文本，但侧重点各不相同，其中属awk功能最强大，但也最复杂。grep更适合单纯的查找或匹配文本，sed更适合编辑匹配到的文本，awk更适合格式化文本，对文本进行较复杂格式处理。
grep:文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来（匹配到的标红）。grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。
grep的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。
grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。我们利用这些返回值就可进行一些自动化的文本处理工作。
egrep = grep -E：扩展的正则表达式 （除了\&amp;lt; , \&amp;gt; , \b 使用其他正则都可以去掉\）</description>
      
    </item>
    
    <item>
      <title>操作系统设备管理</title>
      <link>https://example.com/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/</link>
      <pubDate>Sat, 07 May 2022 19:15:26 +0800</pubDate>
      
      <guid>https://example.com/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/</guid>
      
        <description>设备管理 设备控制器 操作系统如何管理多种设备？
设备控制器：为了屏蔽设备之间的差异，每个设备都有一个叫设备控制器 的组件，比如硬盘有硬盘控制器、显示器有视频控制器等。设备控制器里有芯片，它可执行自己的逻辑，也有自己的寄存器，用来与 CPU 进行通信。
输入输出设备分类？ 块设备和字符设备：
 块设备，把数据存储在固定大小的块中，每个块有自己的地址，硬盘、USB 是常见的块设备。 字符设备，以字符为单位发送或接收一个字符流，字符设备是不可寻址的，也没有任何寻道操作，鼠标是常见的字符设备。  IO控制方式   轮询：控制器的寄存器一般会有状态标记位，用来标识输入或输出操作是否完成。让 CPU 一直查寄存器的状态，直到状态标记为完成，很明显，这种方式非常的傻瓜，它会占用 CPU 的全部时间。</description>
      
    </item>
    
    <item>
      <title>操作系统网络系统</title>
      <link>https://example.com/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Sat, 07 May 2022 19:13:48 +0800</pubDate>
      
      <guid>https://example.com/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/</guid>
      
        <description>网络系统 文件怎么发送？ 如果服务端要提供文件传输的功能，我们能想到的最简单的方式是：将磁盘上的文件读取出来，然后通过网络协议发送给客户端。
传统的文件传输：read+write操作。两次系统调用，四次上下文切换，四次拷贝，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的
所以，要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数。
  要想减少上下文切换到次数，就要减少系统调用的次数。</description>
      
    </item>
    
    <item>
      <title>操作系统文件系统</title>
      <link>https://example.com/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Sat, 07 May 2022 19:12:07 +0800</pubDate>
      
      <guid>https://example.com/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid>
      
        <description>文件系统 什么是文件系统？文件系统的基本组成？ 文件系统是操作系统中负责管理持久数据的子系统。说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。
文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。
Linux 最经典的一句话是：「一切皆文件」，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。
文件系统的基本操作单位是数据块。
文件的数据结构？什么是inode？有什么用？ Linux 文件系统会为每个文件分配两个数据结构：索引节点（index node）和目录项（directory entry），它们主要用来记录文件的元信息和目录层次结构。</description>
      
    </item>
    
    <item>
      <title>操作系统调度算法</title>
      <link>https://example.com/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 07 May 2022 19:10:40 +0800</pubDate>
      
      <guid>https://example.com/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</guid>
      
        <description>调度算法 操作系统的三大调度机制，分别是「进程调度/页面置换/磁盘调度算法」。6+5+5
进程/CPU调度算法有哪些？ 硬件时钟提供某个频率的周期性中断，那么可以根据如何处理时钟中断 ，把调度算法分为两类：
 非抢占式调度算法会让正在运行的进程运行直到被阻塞，或者直到该进程退出，才会调用另外一个进程，也就是说不会理时钟中断这个事情。 抢占式调度算法挑选一个进程，然后让该进程只运行某段时间，如果在该时段结束时，该进程仍然在运行时，则会把它挂起，接着调度程序从就绪队列挑选另外一个进程。这种抢占式调度处理，需要在时间间隔的末端发生时钟中断，以便把 CPU 控制返回给调度程序进行调度，也就是常说的时间片机制。  先来先服务，短作业优先，高响应比优先，时间片轮转，最高优先级，多级反馈队列。</description>
      
    </item>
    
    <item>
      <title>操作系统进程管理</title>
      <link>https://example.com/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</link>
      <pubDate>Sat, 07 May 2022 19:08:46 +0800</pubDate>
      
      <guid>https://example.com/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</guid>
      
        <description>进程管理 进程，线程，协程分别是什么？区别是什么？ 进程：首先进程其实是运行起来的程序，是资源(包括内存、打开的文件等)分配的单位，每个进程都有自己的独立虚拟地址空间，拥有自己独立的堆和栈，上下文切换开销比较大。
线程：线程是 CPU 调度的单位，线程只会有运行时需要的必不可少的资源（程序计数器，寄存器，栈），它的栈是独立的，但是堆是共享的，线程可以享有这个进程内所有的共享资源。上下文切换开销比进程小。线程的作用：线程能减少并发执行的时间和空间开销。（注意：当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃。这里是针对 C/C++ 语言，Java语言中的线程奔溃不会造成进程崩溃）。
协程：一种用户态的轻量级线程，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的。协程和线程一样共享堆，不共享栈，发生上下文切换的时候，因为是用户态的，所以没有内核切换的开销，上下文切换的会比较快。
区别：</description>
      
    </item>
    
    <item>
      <title>操作系统内存管理</title>
      <link>https://example.com/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
      <pubDate>Sat, 07 May 2022 19:07:10 +0800</pubDate>
      
      <guid>https://example.com/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
      
        <description>内存管理 什么是逻辑地址和物理地址？ 我们编程一般只有可能和逻辑地址打交道，比如在 GO 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。
进程地址空间有哪些划分？ 虚拟地址空间的内部又被分为 内核空间 和 用户空间 两部分。</description>
      
    </item>
    
    <item>
      <title>操作系统硬件结构</title>
      <link>https://example.com/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sat, 07 May 2022 19:06:02 +0800</pubDate>
      
      <guid>https://example.com/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/</guid>
      
        <description>硬件结构 冯诺依曼模型 计算机基本结构为 5 个部分，分别是运算器、控制器、存储器、输入设备、输出设备，这 5 个部分也被称为冯诺依曼模型。
运算器、控制器是在CPU里的，存储器就我们常见的内存，输入输出设备则是计算机外接的设备，比如键盘就是输入设备，显示器就是输出设备。
32 位和 64 位 CPU区别，优点？  32 位 CPU 一次可以计算 4 个字节； 64 位 CPU 一次可以计算 8 个字节；  之所以 CPU 要这样设计，是为了能计算更大的数值，所以 CPU 位宽越大，可以计算的数值就越大</description>
      
    </item>
    
    <item>
      <title>操作系统基础</title>
      <link>https://example.com/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sat, 07 May 2022 19:04:46 +0800</pubDate>
      
      <guid>https://example.com/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</guid>
      
        <description>基础 什么是操作系统？ 操作系统是管理计算机硬件与软件资源的程序。常见的操作系统有win, macos, linux, unix。
linux一般指的都是内核，基于Linux内核的发行版有很多。比如ubuntu，centos等等。
什么是系统调用？ 我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！
系统调用类别：</description>
      
    </item>
    
    <item>
      <title>缓存和数据库一致性</title>
      <link>https://example.com/post/%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7/</link>
      <pubDate>Wed, 04 May 2022 16:29:54 +0800</pubDate>
      
      <guid>https://example.com/post/%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7/</guid>
      
        <description>为什么引入缓存 如果业务的流量很小，那么无论读写操作，直接操作数据库即可。但是流量大了之后，直接操作数据库的话就会有性能问题，这时候就需要缓存来提高性能。
redis是一个很好的缓存中间件，性能很好，同时支持丰富的数据类型。通常的做法是读请求去redis读，读写请求可以去mysql去做。
但是这样就面临一个问题，之前只有mysql，数据都在mysql中，现在引入redis，如何把数据从mysql存入redis呢？
如何把数据库中的数据放到缓存中？ 最简单的方案：全量数据刷到缓存
 数据库的数据，全量刷入缓存（不设置失效时间） 写请求只更新数据库，不更新缓存 启动一个定时任务，定时把数据库的数据，更新到缓存中  优点：所有读请求都可以直接「命中」缓存，不需要再查数据库，性能非常高。</description>
      
    </item>
    
    <item>
      <title>Hugo添加自定义页面</title>
      <link>https://example.com/post/hugo%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B5%E9%9D%A2/</link>
      <pubDate>Sat, 30 Apr 2022 18:09:49 +0800</pubDate>
      
      <guid>https://example.com/post/hugo%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B5%E9%9D%A2/</guid>
      
        <description>这里说的页面不是指 hugo 利用 markdown 文件生成的页面，而是我们自己手动创建的 html 页面。
前置知识 一个用hugo生成的网站包含以下文件和文件夹：
 config.</description>
      
    </item>
    
    <item>
      <title>Docker笔记</title>
      <link>https://example.com/post/docker%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 26 Apr 2022 08:57:20 +0800</pubDate>
      
      <guid>https://example.com/post/docker%E7%AC%94%E8%AE%B0/</guid>
      
        <description>Docker概述 Docker 可以让开发者将应用以及依赖打包到一个轻量级可移植的容器中，然后发布到其他机器，也可以实现虚拟化。
历史 :最开始是dotCloud公司做一些云计算的，一开始不火，后来开源火了。基于golang，看官方文档，另外dockerHub类似gitHub。
解决问题 :开发人员开发完给运维人员部署，出现“在我电脑能跑，你那怎么不能跑”的问题。
优点：
 隔离性：每个容器之间相互隔离，可防止环境中的交叉冲突，如端口等。沙箱机制是一种安全机制，为给执行的程序提供隔离环境，沙箱中的一切都可以推翻重来。 轻量：开销低（几兆），启动快（秒级）。 方便弹性扩展：直接多跑个容器就行。 交付部署容易：传统需要安装文档，现在打包成镜像一键部署。 系统运维简单：开发和测试环境一致。 更好利用服务器性能：内核就一个，消耗少了可以利用节省的资源跑更多的容器。  虚拟化技术和容器技术对比：</description>
      
    </item>
    
    <item>
      <title>Git常用命令</title>
      <link>https://example.com/post/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 25 Apr 2022 09:23:16 +0800</pubDate>
      
      <guid>https://example.com/post/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      
        <description>基本知识 下图是git的基本区域：
 workspace：工作区，就是你在电脑里能看到的目录。 staging area：暂存区/缓存区，英文叫 stage 或 index。一般存放在 .git 目录下的 index 文件（.</description>
      
    </item>
    
    <item>
      <title>Go的Channel详解</title>
      <link>https://example.com/post/go%E7%9A%84channel%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sun, 24 Apr 2022 12:26:57 +0800</pubDate>
      
      <guid>https://example.com/post/go%E7%9A%84channel%E8%AF%A6%E8%A7%A3/</guid>
      
        <description>两种类型的channel go官方文档给的是两种，分别是buffered channel和unbuffered channel，也就是有缓冲和无缓冲，go的开发人员更喜欢称之为非阻塞和阻塞的channel。
无缓冲通道又叫同步通道，通道的大小为0，也就是说，这种类型的通道在接收前没有能力保存任何值，它要求发送 goroutine 和接收 goroutine 同时准备好，才可以完成发送和接收操作。也就是说，先执行发送操作的话，由于没有接收的，那么发送操作会被阻塞，同样的，如果先执行接收操作的话，由于没有发送的，所以接收的goroutine会被阻塞。通常用来做并发控制。
有缓冲通道是非同步的，在声明的时候可以设置缓冲容量，只有通道满了才会阻塞。</description>
      
    </item>
    
    <item>
      <title>用Go实现分布式缓存easyCache</title>
      <link>https://example.com/post/%E7%94%A8go%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98easycache/</link>
      <pubDate>Sat, 23 Apr 2022 09:28:32 +0800</pubDate>
      
      <guid>https://example.com/post/%E7%94%A8go%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98easycache/</guid>
      
        <description>常见用来做分布式缓存的有redis和memcached，这篇主要先简单介绍memcached，然后介绍一个用Go语言实现的分布式缓存easycache，会涉及到其设计思想，具体实现，适用场景等，总体上借鉴了groupcache，groupcache是go版的memcached，在有些设计上做了很多简化和优化，他们的作者是同一个人。
MemCached 简介 MemCache是一个自由、源码开放、高性能、分布式的分布式内存对象缓存系统，它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提高了网站访问的速度，减轻数据库的负载。
使用场景 在访问量高的Web网站和应用中使用MemCache，用来缓解数据库的压力，并且提升网站和应用的响应速度，例如页面缓存，访问频繁的数据库数据（身份token、首页动态），搜索的查询条件和结果（热门搜索的内容缓存起来）。
工作流程 存取数据分两步：第一步，选择服务器，第二步存取数据。
如下图，
  客户端请求数据，</description>
      
    </item>
    
    <item>
      <title>Go的GC机制</title>
      <link>https://example.com/post/go%E7%9A%84gc%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Thu, 21 Apr 2022 12:31:50 +0800</pubDate>
      
      <guid>https://example.com/post/go%E7%9A%84gc%E6%9C%BA%E5%88%B6/</guid>
      
        <description>什么是GC（garbage collection）？ 垃圾回收就是对程序中不再使用的内存资源进行自动回收的操作。正常情况下，操作系统会记录一个进程运行时的所占用的内存、CPU和寄存器等资源，当进程结束后便由操作系统能够自动回收资源。但是对于一个运行较长时间的程序，如果使用完内存资源后没有及时释放就会造成内存泄漏。
golang可以在语言层面包含自动的垃圾回收功能，系统可以在CPU相对空闲的时候进行垃圾回收。
垃圾回收的目的是什么？  防止内存泄漏：垃圾回收器最基本的目标就是 减少防止程序员未及时释放 导致的内存泄漏，它会识别并清理内存垃圾。 自动回收无用内存：垃圾回收器作为独立的子任务，不需要程序员显式调用即可自动清理内存垃圾 内存整理：如果只是简单回收无用内存，那么堆上的内存空间会存在较多碎片而无法满足分配较大对象的需求，因此垃圾回收器需要重整内存空间，提高内存利用率。  什么是STW（stop the world ）？  这是一种全局暂停的现象，为了保证在 GC 的过程中，实现的正确性，停止所有其他正在运行的协程。 STW对性能有一些影响，时间越长，影响越大，比如一些对通信时间敏感的，Golang目前已经可以做到1ms以下的STW。  垃圾回收器的原理是什么？ 垃圾回收器的工作流程大体如下：</description>
      
    </item>
    
    <item>
      <title>Go的并发编程</title>
      <link>https://example.com/post/go%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Thu, 21 Apr 2022 12:29:15 +0800</pubDate>
      
      <guid>https://example.com/post/go%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</guid>
      
        <description>讲一下go的并发模型？ go控制并发的话有三种种经典的方式，一种是通过channel通知实现并发控制，一种是WaitGroup，另外一种就是Context。
无缓冲通道又叫同步通道，通道的大小为0，也就是说，这种类型的通道在接收前没有能力保存任何值，它要求发送 goroutine 和接收 goroutine 同时准备好，才可以完成发送和接收操作。也就是说，先执行发送操作的话，由于没有接收的，那么发送操作会被阻塞，同样的，如果先执行接收操作的话，由于没有发送的，所以接收的goroutine会被阻塞。这样子其实就实现了发送和接收goroutine的同步化，也就是并发控制。注意：当一个值在无缓冲通道传递，接收值后发送方goroutine才会被再次唤醒。
例子：
func main() { ch := make(chan struct{}) go func() { ch &amp;lt;- struct{}{} }() fmt.</description>
      
    </item>
    
    <item>
      <title>Go的Map详解</title>
      <link>https://example.com/post/go%E7%9A%84map%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Thu, 21 Apr 2022 12:28:16 +0800</pubDate>
      
      <guid>https://example.com/post/go%E7%9A%84map%E8%AF%A6%E8%A7%A3/</guid>
      
        <description>golang map底层实现？ 底层是一个散列表，因此实现map的过程实际上就是实现散表的过程，go中实现采用拉链法解决冲突。这个散列表里有两个结构体，一个是hmap（(a header for a go map)），一个是bmap（(a bucket for a Go map，通常叫其 bucket)）。</description>
      
    </item>
    
    <item>
      <title>Go的Slice详解</title>
      <link>https://example.com/post/go%E7%9A%84slice%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Thu, 21 Apr 2022 12:25:09 +0800</pubDate>
      
      <guid>https://example.com/post/go%E7%9A%84slice%E8%AF%A6%E8%A7%A3/</guid>
      
        <description>go数组和切片区别？ 数组：长度固定，并且长度也是数组类型的一部分，一般声明的时候要指定大小，不指定也能根据初始化的时候自己算大小，值类型。
切片：底层有三个属性：指针，长度，容量，不需要指定长度容量，可以通过数组初始化也能用make初始化，能够自动扩容。因为基于数组实现，所以它的底层的内存是连续分配的，效率非常高，还可以通过索引获得数据。多个切片底层可能公用同一个底层数组，所以对一个切片的操作可能影响多个slice。
golang中数组和切片在参数传递的时候区别是什么？ 数组是值传递，切片看上去像是引用传递，实际上还是值传递。
讲一下slice的扩容机制？ 根据runtime/slice.go源码，它的扩容情况如下：
newcap := old.cap	//old.</description>
      
    </item>
    
    <item>
      <title>设计模式</title>
      <link>https://example.com/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 21 Apr 2022 12:22:40 +0800</pubDate>
      
      <guid>https://example.com/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      
        <description>设计模式能够帮助我们优化代码结构，让代码更优雅灵活。常见的设计模式有单例模式、工厂模式、装饰模式、策略模式、代理模式和观察者模式等。
单例模式 基本特点 单例模式（Singleton）的目的是为了保证某个类有且仅有一个实例，并提供一个访问它的全局访问点。
主要解决：一个全局使用的类频繁地创建与销毁。为了控制实例数目，节省系统资源的时候。判断系统是否已经有这个单例，如果有则返回，如果没有则创建。
在golang中，
1.命名以小写字母开头，对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 private ）
2.提供一个能够访问这个全局唯一实例的函数GetInstance() *singleton</description>
      
    </item>
    
    <item>
      <title>Go基础</title>
      <link>https://example.com/post/go%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Thu, 21 Apr 2022 12:18:26 +0800</pubDate>
      
      <guid>https://example.com/post/go%E5%9F%BA%E7%A1%80/</guid>
      
        <description>go语言中new和make的区别？ 首先这俩都是内建函数。
new函数会分配内存空间，接受的参数是类型，返回的是该类型的指针，也就是新分配该类型内存地址的指针。new可以分配任意类型的内存空间。
make函数会分配内存空间，接受的参数是类型，返回复合类型的本身。只能是用来为slice，map，chan分配内存并且初始化，返回的是类型本身。注意这三种类型本来就是引用类型。
其实 new 函数在日常工程代码中是比较少见的，因为它是可以被代替，使用T{}方式更加便捷方便。
与其他语言相比，使用 Go 有什么好处?  语法简单：和C很像，删去了很多冗余的语法，比如只保留for循环，去除了while循环，更加统一。 高并发模型：从根上并发化，用goroutine去运行所有的函数，包括main入口函数，goroutine也是go语言的最大特征。并发的语法简单，搭配channel实现CSP模型。 内存分配：go内存分配器用的tcmalloc，就是为了高并发设计的。 垃圾回收：自动垃圾回收，三色标记法和写屏障。 静态链接：编译后形成一个可执行文件，不需要附加任何东西就能部署。将运行时，依赖库直接打包进可执行文件，可以简化部署和发布，不需要再配各种环境和库文件。 标准库：自身标准库丰富，比如net/http，几句话就能构建一个高性能的web server，另外就是第三方库也越来越丰富，比如gozero, excelize等等。 工具链：工具链完整，编译，错误检查，帮助文档，第三方包下载，测试工具，性能测试工具，包依赖管理等等。  Go中的包是什么？ 由一个目录下的一个或多个源文件组成，这些源文件的包名要一致，但与目录名不要求一致，作用类似于namespace，是成员作用域和访问权限的边界。包内成员和相互访问，不管在不在一个源文件。要想让其他包访问首字母要大写。import时可以取别名。</description>
      
    </item>
    
    <item>
      <title>Go的GMP模型详解</title>
      <link>https://example.com/post/go%E7%9A%84gmp%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 20 Apr 2022 23:58:58 +0800</pubDate>
      
      <guid>https://example.com/post/go%E7%9A%84gmp%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/</guid>
      
        <description>什么是GM？1.0之前的GM调度模型 M 想要执行、放回 G 都必须访问全局 G 队列，并且 M 有多个，即多线程访问同一资源需要加锁进行保证互斥 / 同步，所以全局 G 队列是有互斥锁进行保护的。</description>
      
    </item>
    
    <item>
      <title>使用hugo写博客</title>
      <link>https://example.com/post/%E4%BD%BF%E7%94%A8hugo%E5%86%99%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Wed, 20 Apr 2022 09:22:02 +0800</pubDate>
      
      <guid>https://example.com/post/%E4%BD%BF%E7%94%A8hugo%E5%86%99%E5%8D%9A%E5%AE%A2/</guid>
      
        <description>这篇文章会简单介绍如何使用Hugo新增文章，编辑文章，删除文章等日常操作，最后将操作结果同步至github pages。
新增文章 在博客根路径下执行命令即可生成相应的文件：
启动hugo服务，打开http://localhost:1313/ 可实时查看最新的博客效果。
最后做同步到github pages操作即可，见后面同步到github pages部分。
编辑文章 使用vscode或者typora打开刚刚新建的md文件，文件的路径在上面生成的时候有提示。</description>
      
    </item>
    
    <item>
      <title>Github Pages &#43; Hugo 搭建个人博客</title>
      <link>https://example.com/post/hugo&#43;github-pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Tue, 19 Apr 2022 13:44:33 +0800</pubDate>
      
      <guid>https://example.com/post/hugo&#43;github-pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid>
      
        <description>这篇文章会简单介绍如何利用Github Pages和Hugo 搭建一个简单的个人博客，不涉及云服务器及域名购买。
为什么用hugo+github pages搭建个人博客 Hugo:一个用Go语言编写的静态网站生成器，几分钟就能上手，用来生成我们需要的静态的个人博客。优点是修改MarkDown文章后，页面会自动呈现出最终显示效果，能极大的提高博客书写效率。
Github pages：提供免费的静态网站托管服务，用来存放用hugo生成的静态网站的资源，它可以给你提供免费的域名如XXXX.github.io，让别人能访问你的静态个人博客。
两者结合可以搭建好看并且免费的个人博客。
搭建过程 环境：macos 核心步骤 1.</description>
      
    </item>
    
  </channel>
</rss>